
========================================
FILE: adr-001-config-model.md
========================================

# ADR-001: Canonical Configuration Model

**Project:** Dicee — Statistical Engine Upgrade (M1-M4)
**ADR Status:** Proposed
**Version:** 1.0
**Date:** December 5, 2025
**Authors:** Engineering Team
**Reviewers:** TBD

---

## Document Status & Versioning

| Version | Date | Changes | Status |
|---------|------|---------|--------|
| 1.0 | 2025-12-05 | Initial ADR | Current |

**Related Documents:**
- RFC-001: Statistical Engine Architecture
- ADR-002: Transition Probability Strategy (planned)
- ADR-003: Solver Algorithm Selection (planned)
- Workflow: `.claude/workflows/dicee-m1-m4.yaml`

---

## Abstract

This ADR documents the decision to adopt a canonical configuration model using 252 unordered dice representations, replacing the ordered 7,776-outcome model. This is the foundational Layer 0 decision upon which all other architectural layers depend.

---

## Context

### Current State (MVP)

The existing Dicee engine uses ordered dice arrays `[u8; 5]` where each die position is tracked independently:
- Dice values: `[3, 2, 3, 5, 1]` vs `[1, 2, 3, 3, 5]` are treated as distinct
- Total outcome space: 6^5 = **7,776** possible dice states
- Probability calculations enumerate all 7,776 outcomes
- Memory usage scales with outcome count

### Problem

The ordered representation creates unnecessary computational burden:
1. **Redundant states**: `[1,1,2,3,4]` and `[4,3,2,1,1]` have identical scoring and strategic value
2. **Exponential complexity**: Multi-roll analysis requires 7,776^n transitions
3. **Memory pressure**: Full probability matrices would be 7,776 × 7,776 ≈ 60M entries
4. **Wasted computation**: Scoring functions already ignore order internally

### Mathematical Foundation

The number of **unordered** configurations of 5 dice with 6 faces is given by the "stars and bars" combinatorial formula:

```
C(n + k - 1, k) = C(6 + 5 - 1, 5) = C(10, 5) = 252
```

Each configuration represents an equivalence class of ordered outcomes. The size of each class (multiplicity) follows the multinomial coefficient:

```
multiplicity = 5! / (n₁! × n₂! × ... × n₆!)
```

Where `nᵢ` is the count of dice showing face `i`. The sum of all multiplicities equals 7,776.

---

## Decision

**We will adopt a canonical configuration model using 252 unordered dice representations.**

### Core Types

```rust
/// A validated index into the space of 252 configurations.
pub struct ConfigIndex(u8);  // Newtype wrapper, valid range 0-251

/// Canonical unordered representation of 5 dice.
pub struct DiceConfig {
    /// counts[i] = number of dice showing face (i+1)
    counts: [u8; 6],  // Invariant: sum = 5
}
```

### Key Properties

1. **Bijection**: ConfigIndex ↔ DiceConfig is a 1:1 mapping
2. **Normalization**: Any `[u8; 5]` dice array maps to exactly one DiceConfig
3. **Multiplicity tracking**: Each config knows how many ordered arrangements produce it
4. **Compile-time generation**: All 252 configs are computed at compile time

### Implementation

```rust
impl DiceConfig {
    /// Convert ordered dice to canonical form
    pub fn from_dice(dice: &[u8; 5]) -> Self;

    /// Convert to canonical index for table lookups
    pub fn to_index(&self) -> ConfigIndex;

    /// Reconstruct from index
    pub fn from_index(index: ConfigIndex) -> Self;

    /// Number of ordered outcomes that produce this config
    pub fn multiplicity(&self) -> u32;
}
```

---

## Consequences

### Positive

1. **30.86× state space reduction**: 7,776 → 252 configurations
2. **O(1) probability lookups**: Transition tables become practical (252 × 32 × 252)
3. **Memory efficiency**: Solver memoization cache: ~500KB vs ~50MB
4. **Correctness by construction**: Invalid states are unrepresentable
5. **Performance**: <100ns config operations, <1μs transition lookups

### Negative

1. **Migration complexity**: Existing code uses ordered arrays
2. **Type conversion overhead**: Must convert user input to canonical form
3. **Loss of die identity**: Cannot track "which physical die" (acceptable for Dicee)

### Neutral

1. **Learning curve**: Team must understand combinatorial indexing
2. **Testing requirements**: Bijection properties must be verified with property tests
3. **Documentation**: Mathematical foundation must be well-documented

---

## Alternatives Considered

### Alternative 1: Keep Ordered Representation

**Pros:**
- No migration cost
- Intuitive mapping to physical dice

**Cons:**
- 30.86× larger state space
- Impractical for multi-roll analysis
- Higher memory and compute costs

**Why rejected:** Performance and memory requirements for solver are infeasible.

### Alternative 2: Hash Table with Sorted Keys

**Approach:** Use `HashMap<[u8; 5], Value>` with sorted dice as keys.

**Pros:**
- Dynamic, no precomputation
- Familiar API

**Cons:**
- Hash overhead per lookup
- No compile-time validation
- Non-deterministic iteration order
- Memory fragmentation

**Why rejected:** Index-based lookup is faster and more cache-friendly.

### Alternative 3: Perfect Hash Function

**Approach:** Custom hash function mapping dice → [0, 251].

**Pros:**
- Direct array indexing
- No collision handling

**Cons:**
- Complex implementation
- Hash function must be perfect (non-trivial)
- Less intuitive than combinatorial ranking

**Why rejected:** Combinatorial ranking is well-understood and proven correct.

---

## Validation Requirements

### Property-Based Tests

```rust
#[test]
fn prop_config_roundtrip(dice: [u8; 5]) {
    let config = DiceConfig::from_dice(&dice);
    let index = config.to_index();
    let config2 = DiceConfig::from_index(index);
    assert_eq!(config, config2);
}

#[test]
fn prop_multiplicity_sum() {
    let sum: u32 = DiceConfig::iter_all()
        .map(|c| c.multiplicity())
        .sum();
    assert_eq!(sum, 7776);  // 6^5
}

#[test]
fn prop_index_unique() {
    let indices: HashSet<_> = DiceConfig::iter_all()
        .map(|c| c.to_index())
        .collect();
    assert_eq!(indices.len(), 252);
}
```

### Compile-Time Assertions

```rust
static ALL_CONFIGS: [DiceConfig; 252] = generate_all_configs();

const fn generate_all_configs() -> [DiceConfig; 252] {
    // Compile-time generation ensures correctness
}
```

---

## Migration Path

### Phase 1: Add New Types (Non-Breaking)
- Copy `config.rs`, `error.rs` to `packages/engine/src/core/`
- Add `mod core;` to `lib.rs`
- No changes to existing code

### Phase 2: Internal Adoption
- Refactor `scoring.rs` to use `DiceConfig` internally
- Maintain public API unchanged
- Add adapter functions

### Phase 3: API Update (Phase 5a-5d)
- New WASM exports accept ConfigIndex or dice arrays
- Old API deprecated, not removed
- Frontend feature-flagged migration

---

## References

1. **Stars and Bars**: [Combinatorics, Wikipedia](https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics))
2. **Multinomial Coefficients**: [Multinomial Theorem](https://en.wikipedia.org/wiki/Multinomial_theorem)
3. **Dicee Mathematics**: Woodward, "The Mathematics of Dicee" (2009)
4. **Source Implementation**: `/Users/verlyn13/00_inbox/dicee-engine-extracted/dicee-engine/src/core/config.rs`

---

## Decision Record

| Date | Author | Decision |
|------|--------|----------|
| 2025-12-05 | Engineering | ADR Proposed |

**Status:** Awaiting approval before Phase 1 implementation.

========================================
FILE: adr-002-transition-strategy.md
========================================

# ADR-002: Transition Probability Strategy

**Project:** Dicee — Statistical Engine Upgrade (M1-M4)
**ADR Status:** Proposed
**Version:** 1.0
**Date:** December 5, 2025
**Authors:** Engineering Team
**Reviewers:** TBD

---

## Document Status & Versioning

| Version | Date | Changes | Status |
|---------|------|---------|--------|
| 1.0 | 2025-12-05 | Initial ADR | Current |

**Related Documents:**
- ADR-001: Canonical Configuration Model (prerequisite)
- ADR-003: Solver Algorithm Selection (dependent)
- RFC-001: Statistical Engine Architecture
- Workflow: `.claude/workflows/dicee-m1-m4.yaml` (DICEE-005, DICEE-006)

---

## Abstract

This ADR documents the decision to precompute the full transition probability matrix using lazy initialization. The matrix maps (current_config, keep_pattern) pairs to probability distributions over resulting configurations, enabling O(1) lookups for the dynamic programming solver.

---

## Context

### Layer 0 Foundation

With ADR-001, we established 252 canonical dice configurations. The transition probability system (Layer 1) must answer:

> Given dice configuration C and keep pattern K, what is P(C' | C, K) for all possible resulting configurations C'?

### Problem Space

**Keep Patterns**: A keep pattern specifies how many of each face value to keep. For 5 dice with 6 faces:
- Maximum keep patterns per configuration: variable, depends on dice composition
- Conservative upper bound: 2^5 = 32 patterns (treating as binary per-die keep)
- More efficient: Keep patterns are unordered (like configs), further reducing space

**Transition Matrix Size**:
- Naive: 252 configs × 32 keep patterns × 252 target configs = ~2M entries
- Each entry: f64 (8 bytes) → ~16MB uncompressed
- With sparse storage (many zeros): ~4-8MB actual

### Computation Requirements

**Single Transition**: Computing P(C' | C, K) requires:
1. Determine kept dice counts from K
2. Calculate dice to reroll: 5 - sum(kept)
3. Enumerate all roll outcomes for rerolled dice
4. Apply multinomial distribution to each outcome
5. Normalize and sum matching target configs

**Time complexity**: O(6^(5-k)) where k = kept dice count
- Keep 4 dice: O(6) = 6 outcomes
- Keep 2 dice: O(216) = 216 outcomes
- Keep 0 dice: O(7776) = 7776 outcomes

---

## Decision

**We will precompute the full transition probability matrix with lazy initialization.**

### Data Structures

```rust
/// Transition table for probability lookups.
pub struct TransitionTable {
    /// P(target | partial) for all valid (partial, target) pairs.
    /// Indexed by [partial_index][target_config_index].
    probabilities: Vec<Vec<f64>>,
}

/// Partial dice state (after keeping some dice).
pub struct PartialDice {
    /// Counts of kept dice per face.
    kept: KeepPattern,
    /// Number of dice to roll (5 - sum(kept)).
    to_roll: u8,
}

/// Keep pattern: counts of each face value to keep.
pub type KeepPattern = [u8; 6];
```

### Lazy Initialization

```rust
use std::sync::LazyLock;

/// Global transition table, lazily initialized on first access.
pub static TRANSITION_TABLE: LazyLock<TransitionTable> = LazyLock::new(|| {
    TransitionTable::compute()
});
```

### Key Properties

1. **One-time computation**: ~10 seconds in release mode
2. **O(1) lookup**: Direct array indexing after initialization
3. **Memory bounded**: ~16MB maximum, fits in L3 cache
4. **Thread-safe**: LazyLock ensures safe concurrent initialization

---

## Consequences

### Positive

1. **O(1) probability lookup**: Critical for solver performance (<20ms target)
2. **Guaranteed correctness**: Precomputation allows exhaustive validation
3. **Memory predictable**: Fixed ~16MB footprint, no runtime allocation
4. **Cache-friendly**: Dense array access patterns

### Negative

1. **Cold start latency**: ~10s to initialize table on first use
2. **Memory footprint**: 16MB resident memory in all modes
3. **WASM binary size**: Table contributes ~1MB to compressed WASM

### Neutral

1. **Development complexity**: Matrix generation code must be correct
2. **Testing overhead**: Property tests must cover edge cases

---

## Alternatives Considered

### Alternative 1: On-Demand Computation

**Approach:** Compute each transition probability when requested.

**Pros:**
- Zero startup cost
- Minimal memory usage
- Simpler implementation

**Cons:**
- O(6^k) per lookup, infeasible for k > 2
- Solver would require millions of computations
- P95 latency would exceed 100ms

**Why rejected:** Performance requirements mandate O(1) lookups.

### Alternative 2: LRU Cache

**Approach:** Cache computed probabilities with LRU eviction.

**Pros:**
- Adaptive memory usage
- Fast for repeated queries
- Low cold-start cost

**Cons:**
- Cache misses degrade performance unpredictably
- Complex cache invalidation logic
- Memory fragmentation over time
- Still O(6^k) on miss

**Why rejected:** Unpredictable latency unacceptable for real-time UI.

### Alternative 3: Sparse Matrix Storage

**Approach:** Store only non-zero transition probabilities.

**Pros:**
- Reduced memory (~4-8MB vs 16MB)
- Faster iteration over non-zero entries

**Cons:**
- More complex indexing (hash map or CSR format)
- Higher lookup overhead
- Implementation complexity

**Why rejected:** Memory savings insufficient to justify complexity. 16MB is acceptable.

### Alternative 4: External Precomputation (Build-Time)

**Approach:** Generate table at build time, embed in binary.

**Pros:**
- Zero runtime initialization cost
- Smaller WASM (if table stored separately)

**Cons:**
- Build time increases significantly
- Binary size increases dramatically (~16MB)
- Harder to debug/modify
- Platform-specific build requirements

**Why rejected:** Binary size impact unacceptable for web deployment.

---

## Mathematical Foundation

### Multinomial Distribution

For k dice rolled, the probability of outcome O = [n₁, n₂, ..., n₆] where nᵢ = count of face i:

```
P(O) = k! / (n₁! × n₂! × ... × n₆!) × (1/6)^k
```

### Transition Probability

Given kept dice K and target config T:

```
P(T | K) = Σ P(O) for all O where K + O = T
```

Where "+" denotes combining kept dice with rolled outcome.

### Validation Properties

1. **Row sums**: For any (config, keep_pattern), Σ P(target) = 1.0
2. **Symmetry**: Keep all → P(same_config) = 1.0
3. **Uniform reroll**: Keep none → P(config) = multiplicity(config) / 7776

---

## Implementation Notes

### Table Generation Algorithm

```rust
impl TransitionTable {
    pub fn compute() -> Self {
        let mut table = Self::new();

        for partial in PartialDice::iter_all() {
            let probabilities = compute_transition_row(&partial);
            table.set_row(partial.to_index(), probabilities);
        }

        table
    }
}

fn compute_transition_row(partial: &PartialDice) -> Vec<f64> {
    let mut probs = vec![0.0; 252];

    for_each_roll_outcome(partial.to_roll, |outcome| {
        let target = partial.kept.combine(outcome);
        let target_idx = target.to_index().as_usize();
        probs[target_idx] += roll_probability(outcome, partial.to_roll);
    });

    probs
}
```

### Expected Value Computation

```rust
impl TransitionTable {
    /// Compute E[f(target) | partial] for a scoring function f.
    pub fn expected_value<F>(&self, partial: &PartialDice, f: F) -> f64
    where
        F: Fn(&DiceConfig) -> f64,
    {
        let row = self.get_row(partial.to_index());
        row.iter()
            .zip(DiceConfig::iter_all())
            .map(|(&p, config)| p * f(&config))
            .sum()
    }
}
```

---

## Validation Requirements

### Property-Based Tests

```rust
#[test]
fn prop_row_sums_to_one(partial: PartialDice) {
    let sum: f64 = TRANSITION_TABLE
        .get_row(partial.to_index())
        .iter()
        .sum();
    assert!((sum - 1.0).abs() < 1e-9);
}

#[test]
fn prop_keep_all_deterministic(config: DiceConfig) {
    let partial = PartialDice::keep_all(&config);
    let prob = TRANSITION_TABLE.get(partial.to_index(), config.to_index());
    assert!((prob - 1.0).abs() < 1e-9);
}

#[test]
fn prop_reroll_all_matches_multiplicity(config: DiceConfig) {
    let partial = PartialDice::reroll_all();
    let prob = TRANSITION_TABLE.get(partial.to_index(), config.to_index());
    let expected = config.multiplicity() as f64 / 7776.0;
    assert!((prob - expected).abs() < 1e-9);
}
```

### Performance Benchmarks

```rust
#[bench]
fn bench_lookup_single(b: &mut Bencher) {
    let partial = PartialDice::from_kept(&[2, 0, 0, 0, 0, 0]); // Keep two 1s
    let target = ConfigIndex::new(100).unwrap();

    b.iter(|| {
        TRANSITION_TABLE.get(partial.to_index(), target)
    });
}
// Target: < 10ns per lookup
```

---

## Migration Path

### Phase 2 Implementation

1. **Copy keep.rs**: KeepPattern, PartialDice types
2. **Copy transition/probability.rs**: Multinomial calculations
3. **Copy transition/table.rs**: TransitionTable with lazy init
4. **Add module**: `pub mod transition;` in lib.rs
5. **Verify**: All property tests pass

### Integration with Solver (Phase 4)

```rust
// Solver uses transition table for expected value calculation
let ev_continue = TRANSITION_TABLE.expected_value(&partial, |config| {
    solver.evaluate(&TurnState::new(config, rolls - 1), available)
});
```

---

## References

1. **Multinomial Distribution**: [Wikipedia](https://en.wikipedia.org/wiki/Multinomial_distribution)
2. **Lazy Static Pattern**: Rust `std::sync::LazyLock` documentation
3. **Source Implementation**: `/Users/verlyn13/00_inbox/dicee-engine-extracted/dicee-engine/src/transition/`

---

## Decision Record

| Date | Author | Decision |
|------|--------|----------|
| 2025-12-05 | Engineering | ADR Proposed |

**Status:** Awaiting approval before Phase 2 implementation.

========================================
FILE: rfc-001-statistical-engine.md
========================================

# RFC-001: Statistical Engine Architecture
**Project:** Dicee — Educational Probability Platform  
**RFC Status:** Draft → Review → Accepted  
**Version:** 2.0  
**Date:** October 25, 2025  
**Authors:** Engineering Team  
**Reviewers:** TBD

---

## Document Status & Versioning

| Version | Date | Changes | Status |
|---------|------|---------|--------|
| 1.0 | 2025-10-25 | Initial architecture draft | Superseded |
| 2.0 | 2025-10-25 | RFC format, service contracts, math spec, API tables | Current |

**Related RFCs:**
- RFC-002: Educational Alignment & Curriculum Integration (TBD)
- RFC-003: Data Contracts & Event Schema (TBD)
- RFC-004: Frontend-Backend Integration Contract (TBD)
- RFC-005: Adaptive Learning Model Specification (TBD)

---

## Abstract

This RFC specifies the architecture, algorithms, and implementation plan for the **Dicee Statistical Engine**, the mathematical core that transforms Dicee from a casual dice game into an educational instrument for teaching probability, expected value, and optimal decision-making. The engine provides real-time probabilistic analysis with <100ms latency, adaptive complexity scaling for learners from middle school to advanced, and mathematically guaranteed correctness.

**Key Innovation:** Event-sourced statistical observability pipeline that captures every micro-decision, enabling unprecedented insight into probabilistic thinking development.

---

## Table of Contents

1. [Motivation & Design Goals](#1-motivation--design-goals)
2. [System Architecture](#2-system-architecture)
3. [Service Contracts & Boundaries](#3-service-contracts--boundaries)
4. [Domain Mathematics Specification](#4-domain-mathematics-specification)
5. [API Specification](#5-api-specification)
6. [Core Data Models](#6-core-data-models)
7. [Algorithms & Complexity Analysis](#7-algorithms--complexity-analysis)
8. [Data Validation & Correctness Guarantees](#8-data-validation--correctness-guarantees)
9. [Performance & Scalability](#9-performance--scalability)
10. [Security & Fair Play](#10-security--fair-play)
11. [Testing & Validation Strategy](#11-testing--validation-strategy)
12. [Implementation Roadmap](#12-implementation-roadmap)
13. [Sample Execution Trace](#13-sample-execution-trace)
14. [Research References](#14-research-references)
15. [Appendices](#15-appendices)

---

## 1. Motivation & Design Goals

### 1.1 Problem Statement

Existing probability education tools suffer from three critical weaknesses:

1. **Abstraction Gap** — Probability is taught through abstract examples (coin flips, urns) that don't engage learners emotionally or strategically
2. **Passive Learning** — Students observe probabilities but don't make consequential decisions based on them
3. **No Feedback Loop** — Learners cannot measure their probabilistic reasoning quality or track improvement

**Dicee's Solution:** Transform Dicee (a familiar, engaging game) into a statistical laboratory where every decision generates immediate, measurable feedback on probabilistic thinking quality.

### 1.2 Design Principles

**Principle 1: Educational Transparency**  
Every statistical calculation must be explainable, traceable, and verifiable. No "black box" recommendations.

**Principle 2: Performance as Pedagogy**  
Statistical feedback must feel instantaneous (<100ms) to maintain flow state and enable rapid experimentation.

**Principle 3: Progressive Complexity**  
Statistical presentation adapts from simple percentages (beginner) to mathematical proofs (expert) based on demonstrated mastery.

**Principle 4: Correctness Over Approximation**  
When exact calculation is feasible, use exact methods. Monte Carlo is for validation and edge cases, not primary computation.

**Principle 5: Observable Learning**  
Every decision generates rich telemetry enabling unprecedented insight into probabilistic reasoning development.

### 1.3 Non-Goals

This system explicitly **does not**:
- Teach Dicee rules (assumed prerequisite)
- Provide general statistics education (focused on decision-making)
- Support real-money gambling (educational only)
- Replace human teachers (augmentation, not replacement)

### 1.4 Success Criteria

**Technical:**
- P95 latency <100ms for all probability calculations
- >99.9% accuracy vs. theoretical values
- Zero critical correctness bugs in production

**Educational:**
- Average player decision quality improves >15% over 20 games
- >60% of beginners achieve optimal play after 10 games
- >70% of players view post-game statistical analysis

---

## 2. System Architecture

### 2.1 High-Level Architecture

The Statistical Engine employs a **hybrid microservices architecture** with three computational tiers:

```
┌──────────────────────────────────────────────────────────────────┐
│                    Client (Browser / Mobile)                      │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │         Probability Engine (WASM)                          │  │
│  │  • Exact single-roll probabilities                         │  │
│  │  • Lookup table (70K pre-computed states)                  │  │
│  │  • Zero network latency                                    │  │
│  │  • Runs at 60fps during UI interactions                   │  │
│  └────────────────────────────────────────────────────────────┘  │
│                            ↕                                      │
└────────────────────────────┼───────────────────────────────────────┘
                             │ WebSocket / REST
┌────────────────────────────┼───────────────────────────────────────┐
│                    API Gateway (Bun)                              │
│  • Request routing                                                │
│  • Rate limiting (100 req/s per user)                            │
│  • Response caching (Redis)                                       │
│  • Failure orchestration                                          │
└────────────────────────────┬───────────────────────────────────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
┌───────▼──────────┐  ┌──────▼──────────┐  ┌────▼──────────────┐
│ Decision Analyzer│  │ Monte Carlo     │  │ Learning Tracker  │
│ (Bun/TypeScript) │  │ Simulator       │  │ (Python/FastAPI)  │
│                  │  │ (Python/Numba)  │  │                   │
│ • EV calculation │  │ • 100K+ sims    │  │ • Skill profiling │
│ • Optimal moves  │  │ • GPU-accel     │  │ • Progress track  │
│ • Recommendations│  │ • Validation    │  │ • Adaptivity      │
│ • Real-time      │  │ • Background    │  │ • Eventually      │
│   (<50ms)        │  │   (200-500ms)   │  │   consistent      │
└──────────────────┘  └─────────────────┘  └───────────────────┘
        │                    │                    │
        └────────────────────┼────────────────────┘
                             │
                ┌────────────▼────────────┐
                │    Event Store          │
                │  PostgreSQL 16 + Redis  │
                │                         │
                │  • Game events (append) │
                │  • Stats cache (TTL)    │
                │  • Materialized views   │
                └─────────────────────────┘
```

### 2.2 Architectural Rationale

**Why Hybrid (Client + Server)?**
- **Client-side WASM:** Zero-latency for 90% of common calculations
- **Server-side Services:** Heavy computation, cross-player analytics, data persistence

**Why Microservices?**
- **Independent scaling:** Monte Carlo needs more CPU, Learning Tracker more memory
- **Technology specialization:** Rust for speed, Python for scientific computing
- **Failure isolation:** One service failing doesn't crash entire system

**Why Event Sourcing?**
- **Temporal queries:** "Show me all games where player chose suboptimally"
- **Replay capability:** Debug decision recommendations by replaying game state
- **Analytics foundation:** Every decision point captured for learning science research

### 2.3 Data Flow Diagram

**Critical Path (Real-Time Calculation):**

```
User rolls dice
    ↓
Frontend captures: [5,5,5,2,6]
    ↓
WASM Engine: Calculate P(categories)
    ├─→ Cache hit? Return in 3ms
    └─→ Cache miss? Compute in 15ms
    ↓
Display probabilities in UI
    ↓
User hovers "Full House"
    ↓
Decision Analyzer: Calculate EV
    ├─→ Simple state? Return in 8ms
    └─→ Complex state? Query Monte Carlo (200ms, show loading)
    ↓
Display recommendation
    ↓
User scores category
    ↓
Write ScoreDecisionEvent
    ↓
Learning Tracker: Update skill profile (async, 50ms)
    ↓
Return feedback: "Optimal decision! +0.2 EV vs expected"
```

**Total Latency Budget:**
- WASM calculation: 15ms (P95)
- Network RTT: 20ms (P95)
- Decision Analyzer: 30ms (P95)
- Database write: 10ms (P95)
- **Total: 75ms** (within 100ms SLA)

---

## 3. Service Contracts & Boundaries

### 3.1 Probability Engine (WASM/Rust)

**Purpose:** Ultra-fast exact probability calculations for common game states

**Guarantees:**
- ✅ Calculations are mathematically exact (not approximations)
- ✅ Deterministic: same input always produces same output
- ✅ Results always sum to ≤1.0 (probability axioms)
- ✅ Latency <20ms (P95) for any single calculation

**Refuses To:**
- ❌ Handle states requiring >10M enumeration iterations
- ❌ Persist data (stateless computation only)
- ❌ Perform Monte Carlo simulation (different service)

**Dependencies:**
- None (fully self-contained)

**Failure Modes:**
- **Invalid input** → Returns error immediately (no fallback)
- **WASM module load failure** → Frontend falls back to server-side Decision Analyzer
- **Out of memory** → Cannot occur (max stack size: 1MB for 5-dice calculation)

**API Surface:**

```typescript
interface ProbabilityEngineWASM {
  // Primary calculation method
  calculateProbabilities(
    dice: Uint8Array,        // [1-6, 1-6, 1-6, 1-6, 1-6]
    keptMask: Uint8Array,    // [0/1, 0/1, 0/1, 0/1, 0/1]
    rollsLeft: number        // 0-3
  ): ProbabilityVector | Error;
  
  // Lookup table query (fast path)
  lookupProbabilities(
    stateKey: string
  ): ProbabilityVector | null;
  
  // Cache statistics
  getCacheStats(): {
    size: number;
    hitRate: number;
    coverage: number;
  };
}
```

**Service Contract:**

| Input Constraint | Behavior |
|------------------|----------|
| dice.length ≠ 5 | Reject with ValidationError |
| dice[i] ∉ [1,6] | Reject with ValidationError |
| keptMask.length ≠ 5 | Reject with ValidationError |
| rollsLeft ∉ [0,3] | Reject with ValidationError |
| Valid inputs | Return ProbabilityVector in <20ms |

---

### 3.2 Decision Analyzer (Bun/TypeScript)

**Purpose:** Real-time expected value calculation and decision recommendations

**Guarantees:**
- ✅ Provides optimal (highest EV) decision recommendation
- ✅ Includes human-readable reasoning for recommendation
- ✅ Returns alternative strategies with EV differences
- ✅ Latency <100ms (P95) including explanation generation

**Refuses To:**
- ❌ Return recommendations without EV calculation
- ❌ Suggest illegal moves (already-used categories)
- ❌ Generate explanations longer than 200 chars (UX constraint)

**Dependencies:**
- Probability Engine (WASM) for base probabilities
- Monte Carlo Simulator (optional, for validation)
- Redis (for memoization cache)

**Failure Modes:**
- **Probability Engine unavailable** → Falls back to pre-computed heuristics
- **Redis cache miss** → Compute fresh (slower but correct)
- **Monte Carlo timeout** → Return best-effort EV estimate
- **LLM explanation failure** → Return template explanation

**Fallback Cascade:**

```
Decision Analyzer
    ↓ (fails)
Cached EV lookup
    ↓ (cache miss)
Monte Carlo estimation (500ms timeout)
    ↓ (timeout)
Heuristic-based recommendation
    ↓ (all else fails)
"Unable to provide recommendation"
```

**API Surface:**

```typescript
interface DecisionAnalyzer {
  // Calculate EV for all available actions
  calculateEV(
    gameState: GameState
  ): Promise<EVComparison>;
  
  // Get optimal decision with reasoning
  getRecommendation(
    gameState: GameState,
    explanationDepth: 'simple' | 'detailed' | 'expert'
  ): Promise<DecisionRecommendation>;
  
  // Evaluate user's decision quality
  evaluateDecision(
    gameState: GameState,
    chosenAction: Action
  ): Promise<DecisionQualityScore>;
}
```

---

### 3.3 Monte Carlo Simulator (Python/Numba)

**Purpose:** Heavy-duty statistical simulation for validation and edge cases

**Guarantees:**
- ✅ Results converge to theoretical values within specified confidence level
- ✅ Parallelized across all CPU cores
- ✅ Deterministic given same random seed
- ✅ Configurable iteration count (10K - 10M)

**Refuses To:**
- ❌ Run simulations with <1,000 iterations (statistically meaningless)
- ❌ Block critical path (async only)
- ❌ Consume >80% CPU (resource limit)

**Dependencies:**
- NumPy, Numba JIT compiler
- Optional: CUDA for GPU acceleration

**Failure Modes:**
- **Numba compilation failure** → Falls back to pure Python (slower)
- **Out of memory** → Reduces batch size automatically
- **Timeout (>5s)** → Returns partial results with warning

**API Surface:**

```python
class MonteCarloSimulator:
    def simulate(
        self,
        scenario: GameState,
        target_category: str,
        iterations: int = 100_000,
        confidence_level: float = 0.95
    ) -> SimulationResult:
        """
        Run Monte Carlo simulation
        
        Returns:
            SimulationResult with:
            - probability: float
            - confidence_interval: (lower, upper)
            - actual_iterations: int (may be less if timeout)
        """
```

---

### 3.4 Learning Tracker (Python/FastAPI)

**Purpose:** Track player skill progression and adapt statistical presentation

**Guarantees:**
- ✅ Skill ratings converge within 20 games
- ✅ Detects error patterns with >80% accuracy
- ✅ Eventually consistent (async updates acceptable)
- ✅ Privacy-preserving (no PII in analytics)

**Refuses To:**
- ❌ Block real-time gameplay (async only)
- ❌ Change skill rating mid-game (stability)
- ❌ Share individual player data cross-account

**Dependencies:**
- PostgreSQL (persistent storage)
- Redis (skill profile cache)
- scikit-learn (skill classification)

**Failure Modes:**
- **Database unavailable** → Queues updates in Redis
- **Skill calculation error** → Uses last known rating
- **Cache miss** → Queries database (slower)

**API Surface:**

```python
class LearningTracker:
    async def record_decision(
        self,
        player_id: str,
        decision_event: DecisionEvent
    ) -> None:
        """Record decision for skill assessment (async)"""
    
    async def get_skill_profile(
        self,
        player_id: str
    ) -> PlayerSkillProfile:
        """Get current skill profile (cached)"""
    
    async def update_skill_rating(
        self,
        player_id: str,
        game_id: str
    ) -> SkillUpdate:
        """Recalculate skill after game completion"""
```

---

### 3.5 Event Store (PostgreSQL + Redis)

**Purpose:** Durable persistence and caching layer

**Guarantees:**
- ✅ All events stored durably (append-only)
- ✅ Point-in-time queries supported
- ✅ Write latency <10ms (P95)
- ✅ Read latency <5ms (P95) for cached data

**Refuses To:**
- ❌ Allow event deletion (immutability)
- ❌ Serve real-time queries from cold storage
- ❌ Cache sensitive data in Redis

**Dependencies:**
- PostgreSQL 16 (primary storage)
- Redis/Valkey (cache + session state)
- pg_cron (materialized view refresh)

**Failure Modes:**
- **Postgres unavailable** → Queues writes in Redis, reject reads
- **Redis unavailable** → Direct to Postgres (slower)
- **Disk full** → Reject writes, alert immediately

---

## 4. Domain Mathematics Specification

### 4.1 Probability Space Definition

**Sample Space (Ω):**  
The set of all possible dice outcomes for a 5-dice roll:

```
Ω = {1,2,3,4,5,6}^5
|Ω| = 6^5 = 7,776 possible outcomes
```

**Events:**  
Measurable subsets of Ω corresponding to Dicee categories

**Probability Measure (P):**  
For fair dice, uniform distribution over Ω:

```
P(outcome) = 1/7776  for all outcomes ∈ Ω
P(event E) = |E| / 7776
```

**Assumptions:**
1. All dice are independent
2. All dice are fair (P(face) = 1/6)
3. Dice are distinguishable (order matters for counting)

### 4.2 Category Definitions (Formal)

**Upper Section (Ones through Sixes):**

```
Ones(d₁,d₂,d₃,d₄,d₅) = Σ[i=1 to 5] 1(dᵢ = 1)
Score = count(1s) × 1

Similarly for 2s-6s with different target values.
```

**Three of a Kind:**

```
ThreeOfKind(dice) = ∃v ∈ {1..6}: count(dice, v) ≥ 3
Score = Σ dice if condition holds, else 0
```

**Four of a Kind:**

```
FourOfKind(dice) = ∃v ∈ {1..6}: count(dice, v) ≥ 4
Score = Σ dice if condition holds, else 0
```

**Full House:**

```
FullHouse(dice) = ∃a,b ∈ {1..6}: a≠b ∧ count(dice,a)=3 ∧ count(dice,b)=2
Score = 25 if condition holds, else 0
```

**Small Straight:**

```
SmallStraight(dice) = ∃sequence ∈ {{1,2,3,4}, {2,3,4,5}, {3,4,5,6}}:
                       sequence ⊆ set(dice)
Score = 30 if condition holds, else 0
```

**Large Straight:**

```
LargeStraight(dice) = set(dice) ∈ {{1,2,3,4,5}, {2,3,4,5,6}}
Score = 40 if condition holds, else 0
```

**Dicee:**

```
Dicee(dice) = ∃v ∈ {1..6}: ∀i ∈ {1..5}: dᵢ = v
Score = 50 if condition holds, else 0
```

**Chance:**

```
Chance(dice) = Σ dice
Score = sum of all dice (always valid)
```

### 4.3 Probability Calculation (Exact Method)

**Single-Roll Probability:**

For a roll with `k` dice to reroll:

```
P(category | dice, keep_mask) = 
    |{outcomes where category achieved}| / 6^k

where k = count(keep_mask = False)
```

**Combinatorial Counting:**

Number of ways to roll specific dice values:

```
Ways(counts) = n! / (c₁! × c₂! × ... × c₆!)

where:
  n = total dice
  cᵢ = count of dice showing value i
```

**Example:** Ways to roll [3,3,3,5,6]

```
Ways = 5! / (3! × 1! × 1!) = 120 / 6 = 20
```

### 4.4 Expected Value Recurrence Relation

**Bellman Equation for Dicee:**

```
V*(state) = max(
    max{Score(cat) | cat ∈ Available},           // Terminal action
    max{EV(reroll strategy) | strategy ∈ Keeps}  // Continue action
)

where:
  EV(reroll strategy) = Σ P(outcome) × V*(new_state(outcome))
```

**Base Case:**

```
V*(state with rolls=0) = max{Score(cat) | cat ∈ Available}
```

**Optimal Policy:**

```
π*(state) = argmax{V*(action) | action ∈ Actions}
```

### 4.5 Confidence Intervals (Monte Carlo)

For `n` simulations with success count `k`:

```
p̂ = k/n  (empirical probability)

Standard error: SE = √(p̂(1-p̂)/n)

95% CI: [p̂ - 1.96×SE, p̂ + 1.96×SE]
```

**Required samples for ±1% accuracy:**

```
n ≥ (1.96/0.01)² × p(1-p) ≈ 38,416 for p=0.5 (worst case)
```

### 4.6 Decision Quality Metric

**EV Difference:**

```
Δ_EV = EV(action_chosen) - EV(action_optimal)

Always: Δ_EV ≤ 0 (optimal has highest EV by definition)
```

**Cumulative Skill Score:**

```
Skill(player) = -1 × mean{Δ_EV(decision_i) | i=1..N}

Higher is better (closer to 0 means more optimal)
```

### 4.7 Invariants & Axioms

**Probability Axioms:**
1. `0 ≤ P(E) ≤ 1` for all events E
2. `P(Ω) = 1` (something must happen)
3. `P(A ∪ B) = P(A) + P(B)` if A and B are mutually exclusive

**Dicee-Specific Invariants:**
1. All category scores are non-negative integers
2. Upper section max: 5 × 6 = 30 per category
3. Upper section bonus: 35 if total ≥ 63
4. Grand total is sum of all scored categories + bonuses
5. Exactly 13 decisions per game (one per category)

**Computation Invariants:**
1. EV monotonicity: `EV(state, rolls=k+1) ≥ EV(state, rolls=k)`
2. Probability sum: `Σ P(category) ≤ 1.0` (categories may overlap)
3. Cache consistency: Cached values match fresh calculations

---

## 5. API Specification

### 5.1 REST API Endpoints

**Base URL:** `https://api.dicee.app/v1`

| Method | Endpoint | Purpose | Latency SLA | Auth |
|--------|----------|---------|-------------|------|
| GET | `/probabilities` | Get probability vector | <50ms | No |
| POST | `/decision` | Get optimal decision | <100ms | No |
| POST | `/evaluate` | Grade player decision | <50ms | No |
| POST | `/simulate` | Run Monte Carlo | <500ms | No |
| GET | `/game/{id}/state` | Get game state | <20ms | Yes |
| POST | `/game/{id}/roll` | Record roll event | <30ms | Yes |
| POST | `/game/{id}/score` | Record score event | <50ms | Yes |
| GET | `/player/{id}/profile` | Get skill profile | <100ms | Yes |
| GET | `/game/{id}/report` | Get game report | <5s | Yes |

### 5.2 Endpoint Specifications

#### POST `/v1/probabilities`

**Request Schema:**

```typescript
{
  "dice": [5, 5, 5, 2, 6],           // Current dice state
  "keptMask": [true, true, true, false, false],
  "rollsRemaining": 1,
  "availableCategories": ["full_house", "fives", "chance"]
}
```

**Response Schema (Success):**

```typescript
{
  "status": "success",
  "computationTime": 12,  // milliseconds
  "method": "exact",       // "exact" | "monte_carlo" | "cached"
  "probabilities": {
    "full_house": {
      "value": 0.1667,
      "asPercentage": "16.7%",
      "asFraction": "1/6",
      "confidence": 1.0,   // 1.0 = exact, <1.0 = estimated
      "isAchievable": true
    },
    "fives": {
      "value": 1.0,
      "asPercentage": "100%",
      "asFraction": "1/1",
      "confidence": 1.0,
      "isAchievable": true
    },
    "chance": {
      "value": 1.0,
      "asPercentage": "100%",
      "confidence": 1.0,
      "isAchievable": true
    }
  },
  "cacheHit": false,
  "traceId": "uuid-v4"
}
```

**Response Schema (Error):**

```typescript
{
  "status": "error",
  "errorCode": "INVALID_DICE_STATE",
  "message": "Dice must contain exactly 5 values between 1-6",
  "traceId": "uuid-v4"
}
```

**Error Codes:**
- `INVALID_DICE_STATE` — Malformed dice input
- `INVALID_KEPT_MASK` — kept_mask length ≠ 5
- `COMPUTATION_TIMEOUT` — Exceeded 100ms deadline
- `SERVICE_UNAVAILABLE` — Backend services down

---

#### POST `/v1/decision`

**Request Schema:**

```typescript
{
  "gameState": {
    "dice": [5, 5, 5, 2, 6],
    "rollsRemaining": 1,
    "availableCategories": ["full_house", "fives", "chance"],
    "currentScore": 145
  },
  "explanationDepth": "detailed"  // "simple" | "detailed" | "expert"
}
```

**Response Schema:**

```typescript
{
  "status": "success",
  "recommendation": {
    "action": "score",
    "category": "fives",
    "expectedValue": 15.0,
    "confidence": "high",
    "reasoning": "Guaranteed 15 points. Rerolling risks losing value for uncertain Full House gain.",
    "alternatives": [
      {
        "category": "full_house",
        "expectedValue": 11.67,  // 25 × 0.1667 + 0 × 0.8333
        "evDifference": -3.33,
        "reasoning": "Only 16.7% chance (1/6) of achieving full house"
      },
      {
        "category": "chance",
        "expectedValue": 28.0,
        "evDifference": 13.0,
        "reasoning": "Optimal choice: guaranteed maximum points"
      }
    ]
  },
  "computationTime": 45,
  "traceId": "uuid-v4"
}
```

---

#### POST `/v1/evaluate`

**Request Schema:**

```typescript
{
  "gameState": {
    "dice": [5, 5, 5, 2, 6],
    "rollsRemaining": 0,
    "availableCategories": ["full_house", "fives", "chance"]
  },
  "chosenCategory": "fives",
  "pointsEarned": 15,
  "timeToDecision": 3500  // milliseconds
}
```

**Response Schema:**

```typescript
{
  "status": "success",
  "evaluation": {
    "quality": "suboptimal",  // "optimal" | "excellent" | "good" | "acceptable" | "suboptimal" | "poor"
    "evDifference": -13.0,
    "optimalCategory": "chance",
    "optimalEV": 28.0,
    "chosenEV": 15.0,
    "feedback": "You chose Fives (15 pts) but Chance would have scored 28 pts. Consider using Chance for high-value mixed dice.",
    "missedPoints": 13,
    "learningTip": "Chance is most valuable when you have high dice values with no clear category fit."
  },
  "traceId": "uuid-v4"
}
```

---

### 5.3 WASM Module API

**Module:** `@dicee/probability-engine` (npm package)

```typescript
import init, { ProbabilityEngine } from '@dicee/probability-engine';

// Initialize WASM module (async, one-time)
await init();

const engine = new ProbabilityEngine();

// Calculate probabilities
const result = engine.calculate_probabilities(
  new Uint8Array([5, 5, 5, 2, 6]),      // dice
  new Uint8Array([1, 1, 1, 0, 0]),      // kept (1=true, 0=false)
  1                                      // rolls remaining
);

// Result is JSON string
const probabilities = JSON.parse(result);
```

**Module Size:** ~150KB gzipped

**Browser Support:**
- Chrome/Edge 91+
- Firefox 89+
- Safari 15+
- iOS Safari 15+

---

### 5.4 WebSocket Protocol (Real-Time Updates)

**Connection:** `wss://api.dicee.app/v1/game/{gameId}`

**Client → Server Messages:**

```typescript
// Join game
{
  "type": "join",
  "playerId": "uuid",
  "token": "jwt-token"
}

// Roll dice
{
  "type": "roll",
  "keptMask": [true, false, false, true, false]
}

// Score category
{
  "type": "score",
  "category": "full_house"
}

// Request hint
{
  "type": "request_hint",
  "explanationDepth": "detailed"
}
```

**Server → Client Messages:**

```typescript
// Game state update
{
  "type": "state_update",
  "gameState": { /* full game state */ },
  "timestamp": 1698765432000
}

// Roll result
{
  "type": "roll_result",
  "dice": [3, 3, 5, 5, 6],
  "rollNumber": 2,
  "probabilities": { /* computed probabilities */ }
}

// Turn changed
{
  "type": "turn_changed",
  "newPlayerId": "uuid",
  "playerName": "Alice"
}

// Hint delivered
{
  "type": "hint",
  "recommendation": { /* decision recommendation */ }
}

// Error
{
  "type": "error",
  "code": "INVALID_ACTION",
  "message": "Not your turn"
}
```

---

## 6. Core Data Models

### 6.1 Event Schema

All events follow this base structure:

```typescript
interface BaseGameEvent {
  // Event identity
  id: string;                    // UUID v4
  eventType: string;              // Specific event type
  eventVersion: string;           // "1.0.0" (schema version)
  timestamp: number;              // Unix epoch milliseconds
  
  // Event correlation
  traceId: string;                // For request tracing
  causalChain: string[];          // Parent event IDs
  
  // Game context
  gameId: string;
  playerId: string;
  turnNumber: number;             // 1-13
  rollNumber: number;             // 1-3
  
  // Execution metadata
  computationTime?: number;       // ms
  serviceName?: string;           // Which service generated this
}
```

**Specific Event Types:**

```typescript
// Roll event
interface RollEvent extends BaseGameEvent {
  eventType: "roll";
  diceResult: [number, number, number, number, number];
  keptMask: [boolean, boolean, boolean, boolean, boolean];
  
  // Pre-roll context
  preRollDice?: [number, number, number, number, number];
  intentSignal?: "exploring" | "targeting_category" | "conservative";
  
  // Computed statistics
  probabilities: ProbabilityVector;
  recommendations: DecisionRecommendation[];
}

// Score decision event
interface ScoreDecisionEvent extends BaseGameEvent {
  eventType: "score";
  chosenCategory: DiceeCategory;
  pointsEarned: number;
  
  // Decision quality
  expectedValue: number;
  optimalCategory: DiceeCategory;
  optimalEV: number;
  evDifference: number;
  decisionQuality: "optimal" | "excellent" | "good" | "acceptable" | "suboptimal" | "poor";
  
  // Behavioral telemetry
  timeToDecision: number;           // ms from roll to score
  categoriesConsidered: string[];   // Hover sequence
  backtrackCount: number;           // Changes of mind
  hintRequested: boolean;
}

// Hover event (UI telemetry)
interface HoverEvent extends BaseGameEvent {
  eventType: "hover";
  categoryHovered: DiceeCategory;
  hoverDuration: number;            // ms
  
  // Contextual calculation
  wouldScore: number;
  currentEV: number;
  isOptimal: boolean;
}

// Prediction event (engagement mechanic)
interface PredictionEvent extends BaseGameEvent {
  eventType: "prediction";
  predictedCategory: DiceeCategory;
  predictedProbability: number;
  actualProbability: number;
  accuracyDelta: number;            // For reward calculation
}
```

### 6.2 Game State Model

```typescript
interface GameState {
  gameId: string;
  status: "waiting" | "active" | "completed" | "abandoned";
  
  // Players
  players: PlayerState[];
  currentPlayerId: string;
  turnOrder: string[];
  
  // Current turn state
  currentTurn: number;              // 1-13
  currentRoll: number;              // 1-3
  currentDice: [number, number, number, number, number];
  keptDice: [boolean, boolean, boolean, boolean, boolean];
  
  // Game history
  events: BaseGameEvent[];          // Full event log
  
  // Timestamps
  createdAt: number;
  startedAt?: number;
  completedAt?: number;
}

interface PlayerState {
  playerId: string;
  displayName: string;
  
  // Scorecard
  scorecard: {
    ones?: number;
    twos?: number;
    threes?: number;
    fours?: number;
    fives?: number;
    sixes?: number;
    upperBonus?: number;            // 35 if upper ≥ 63
    threeOfKind?: number;
    fourOfKind?: number;
    fullHouse?: number;
    smallStraight?: number;
    largeStraight?: number;
    dicee?: number;
    chance?: number;
    diceeBonus?: number;          // 100 per additional Dicee
  };
  
  // Computed totals
  upperTotal: number;
  lowerTotal: number;
  grandTotal: number;
  
  // Available categories (not yet scored)
  availableCategories: Set<DiceeCategory>;
}
```

### 6.3 Probability Vector Model

```typescript
interface ProbabilityVector {
  // Per-category probabilities
  categories: Record<DiceeCategory, ProbabilityMetric>;
  
  // Metadata
  computationMethod: "exact" | "monte_carlo" | "hybrid" | "cached";
  computationTime: number;          // ms
  confidence: number;               // 0.0-1.0 (1.0 = exact)
  cacheHit: boolean;
  
  // Validation
  checksumValid: boolean;           // Σ P ≤ 1.0
  invariantsSatisfied: boolean;
}

interface ProbabilityMetric {
  // Probability values
  value: number;                    // 0.0-1.0
  confidenceInterval?: [number, number];  // [lower, upper] for Monte Carlo
  sampleSize?: number;              // For Monte Carlo
  
  // Multiple representations
  asPercentage: string;             // "23.5%"
  asOdds: string;                   // "1 in 4.3"
  asFraction?: string;              // "5/21" (exact only)
  
  // Decision support
  isAchievable: boolean;
  recommendKeep?: number[];         // Dice indices [0-4]
  
  // Validation
  calculationMethod: string;
  lastComputed: number;             // timestamp
}
```

---

## 7. Algorithms & Complexity Analysis

### 7.1 Single-Roll Exact Probability

**Algorithm:** Combinatorial enumeration

```typescript
function calculateSingleRollProbability(
  currentDice: number[],
  keptMask: boolean[],
  category: DiceeCategory
): Probability {
  const diceToRoll = keptMask.filter(k => !k).length;
  const totalOutcomes = Math.pow(6, diceToRoll);
  
  let favorableOutcomes = 0;
  
  // Enumerate all 6^k possible outcomes
  for (let outcome = 0; outcome < totalOutcomes; outcome++) {
    const newDice = applyReroll(currentDice, keptMask, outcome);
    if (achievesCategory(newDice, category)) {
      favorableOutcomes++;
    }
  }
  
  return {
    value: favorableOutcomes / totalOutcomes,
    numerator: favorableOutcomes,
    denominator: totalOutcomes,
    method: 'exact'
  };
}
```

**Complexity Analysis:**

| Dice to Roll | Iterations | Time (Rust) | Time (JS) |
|--------------|-----------|-------------|-----------|
| 0 | 1 | <1ms | <1ms |
| 1 | 6 | <1ms | <1ms |
| 2 | 36 | <1ms | <1ms |
| 3 | 216 | 1-2ms | 2-3ms |
| 4 | 1,296 | 5-8ms | 10-15ms |
| 5 | 7,776 | 15-20ms | 30-40ms |

**Space Complexity:** O(1) — constant memory

**Optimization:** Pre-compute all 7,776 five-dice states during initialization

---

### 7.2 Multi-Roll Dynamic Programming

**Algorithm:** Recursive EV with memoization

```typescript
function calculateOptimalEV(
  state: GameState,
  cache: Map<string, number>
): number {
  // Base case
  if (state.rollsRemaining === 0) {
    return Math.max(...state.availableCategories.map(
      cat => scoreCategory(state.dice, cat)
    ));
  }
  
  // Check cache
  const key = stateKey(state);
  if (cache.has(key)) {
    return cache.get(key)!;
  }
  
  // Try all keep strategies (32 combinations)
  let bestEV = 0;
  for (const keepMask of generateKeepStrategies()) {
    const rerollEV = calculateRerollEV(state, keepMask, cache);
    bestEV = Math.max(bestEV, rerollEV);
  }
  
  // Also consider scoring now
  const scoreNowEV = calculateTerminalEV(state);
  const optimalEV = Math.max(bestEV, scoreNowEV);
  
  cache.set(key, optimalEV);
  return optimalEV;
}
```

**Complexity Analysis:**

Let:
- `n` = number of available categories (max 13)
- `r` = rolls remaining (max 3)
- `d` = distinct dice states (≈7,776)

**Without Memoization:**
```
T(n, r) = 32 × 6^5 × T(n, r-1)  [recursive calls]
        = O(32^r × 6^5) ≈ O(32^3 × 7776) ≈ 250 million operations
```

**With Memoization:**
```
States to compute = d × 2^n × r
                  ≈ 7776 × 8192 × 3
                  ≈ 190 million states (worst case)

Practical: ~10,000 states visited per game
Time: O(10,000 × 32) ≈ 320K operations → ~50ms
```

**Space Complexity:** O(d × 2^n × r) ≈ 190MB worst case, ~1MB typical

**Optimization:** 
- Symmetry reduction: [1,2,3,3,5] ≡ [3,3,1,2,5]
- Category pruning: Don't consider impossible categories
- Iterative deepening: Compute EV for r=0, then r=1, etc.

---

### 7.3 Monte Carlo Simulation

**Algorithm:** Parallel sampling with Numba

```python
@jit(nopython=True, parallel=True)
def monte_carlo_simulate(
    current_dice: np.ndarray,
    kept_mask: np.ndarray,
    target_category: str,
    n_simulations: int
) -> float:
    success_count = 0
    
    # Parallel loop over CPU cores
    for i in prange(n_simulations):
        outcome = current_dice.copy()
        
        # Simulate reroll
        for j in range(5):
            if not kept_mask[j]:
                outcome[j] = np.random.randint(1, 7)
        
        # Check category achievement
        if check_category_numba(outcome, target_category):
            success_count += 1
    
    return success_count / n_simulations
```

**Complexity Analysis:**

| Iterations | Time (Numba) | Time (Python) | Confidence Interval |
|------------|--------------|---------------|---------------------|
| 1,000 | 2ms | 50ms | ±3.1% |
| 10,000 | 15ms | 500ms | ±1.0% |
| 100,000 | 120ms | 5s | ±0.3% |
| 1,000,000 | 1.2s | 50s | ±0.1% |

**Parallelization Speedup:**

| Cores | Speedup | Time (100K) |
|-------|---------|-------------|
| 1 | 1.0× | 120ms |
| 4 | 3.8× | 32ms |
| 8 | 7.2× | 17ms |
| 16 | 13.5× | 9ms |

**GPU Acceleration (Optional):**
- CUDA kernel: ~2ms for 1M iterations
- Requires NVIDIA GPU with CUDA 11+
- 60× speedup vs. single-core CPU

---

### 7.4 Algorithm Complexity Summary

| Algorithm | Time Complexity | Space Complexity | Typical Runtime |
|-----------|----------------|------------------|-----------------|
| Single-roll probability | O(6^k) | O(1) | 15ms |
| Multi-roll EV (memoized) | O(d × 2^n × r) | O(d × 2^n × r) | 50ms |
| Monte Carlo (100K) | O(n × 5) | O(1) | 120ms |
| Category scoring | O(1) | O(1) | <1ms |
| Optimal strategy lookup | O(1) | O(d × 2^n) | 3ms |
| Game state validation | O(1) | O(1) | <1ms |

**Where:**
- k = dice to roll (0-5)
- d = distinct dice states (≈7,776)
- n = available categories (max 13)
- r = rolls remaining (0-3)

---

## 8. Data Validation & Correctness Guarantees

### 8.1 Input Validation Rules

**Dice State Validation:**

```typescript
function validateDiceState(dice: unknown): dice is number[] {
  if (!Array.isArray(dice)) return false;
  if (dice.length !== 5) return false;
  return dice.every(d => Number.isInteger(d) && d >= 1 && d <= 6);
}
```

**Invariant Checks:**

```typescript
class ProbabilityValidator {
  static validateProbabilityVector(pv: ProbabilityVector): void {
    // Rule 1: All probabilities in [0, 1]
    for (const [category, metric] of Object.entries(pv.categories)) {
      if (metric.value < 0 || metric.value > 1) {
        throw new ValidationError(
          `Probability for ${category} outside [0,1]: ${metric.value}`
        );
      }
    }
    
    // Rule 2: Sum of mutually exclusive categories ≤ 1
    // (Note: categories can overlap, so total sum may exceed 1)
    
    // Rule 3: Confidence intervals are valid
    for (const metric of Object.values(pv.categories)) {
      if (metric.confidenceInterval) {
        const [lower, upper] = metric.confidenceInterval;
        if (lower < 0 || upper > 1 || lower > upper) {
          throw new ValidationError(
            `Invalid confidence interval: [${lower}, ${upper}]`
          );
        }
      }
    }
    
    // Rule 4: If confidence < 1.0, must be Monte Carlo
    if (pv.confidence < 1.0 && pv.computationMethod === 'exact') {
      throw new ValidationError(
        'Exact computation must have confidence = 1.0'
      );
    }
  }
}
```

### 8.2 EV Monotonicity Guarantee

**Theorem:** Expected value is monotonically increasing with more rolls remaining.

```
EV(state, rolls=k+1) ≥ EV(state, rolls=k)  for all k ∈ [0,2]
```

**Proof:** With an additional roll, the player has all previous options (score now) plus new options (reroll). The optimal strategy with k+1 rolls can always choose the same action as with k rolls, so EV cannot decrease.

**Validation:**

```typescript
function validateEVMonotonicity(
  state: GameState,
  ev0: number,
  ev1: number
): void {
  if (ev1 < ev0 - 0.01) {  // Allow 0.01 rounding tolerance
    throw new InvariantViolation(
      `EV monotonicity violated: EV(r=1)=${ev1} < EV(r=0)=${ev0}`
    );
  }
}
```

### 8.3 Score Range Validation

```typescript
const CATEGORY_CONSTRAINTS: Record<DiceeCategory, [number, number]> = {
  ones: [0, 5],              // Min 0, max 5×1
  twos: [0, 10],             // Min 0, max 5×2
  threes: [0, 15],
  fours: [0, 20],
  fives: [0, 25],
  sixes: [0, 30],
  threeOfKind: [0, 30],      // Min 0 (fail), max 5×6
  fourOfKind: [0, 30],
  fullHouse: [0, 25],        // 0 or 25 only
  smallStraight: [0, 30],    // 0 or 30 only
  largeStraight: [0, 40],    // 0 or 40 only
  dicee: [0, 50],          // 0 or 50 only
  chance: [5, 30]            // Min 5×1, max 5×6
};

function validateScore(
  category: DiceeCategory,
  score: number
): void {
  const [min, max] = CATEGORY_CONSTRAINTS[category];
  if (score < min || score > max) {
    throw new ValidationError(
      `Score ${score} for ${category} outside valid range [${min}, ${max}]`
    );
  }
  
  // Additional constraint: fixed-value categories
  if (['full_house', 'small_straight', 'large_straight', 'dicee'].includes(category)) {
    if (score !== 0 && score !== max) {
      throw new ValidationError(
        `${category} must score 0 or ${max}, got ${score}`
      );
    }
  }
}
```

### 8.4 Determinism Guarantee

**Requirement:** Same input always produces same output (no hidden randomness)

```typescript
// ✅ CORRECT: Deterministic probability calculation
function calculateProbability(dice: number[], category: string): number {
  return exactEnumeration(dice, category);  // Pure function
}

// ❌ INCORRECT: Non-deterministic
function calculateProbability(dice: number[], category: string): number {
  if (Math.random() > 0.5) {  // ❌ Random branch
    return exactEnumeration(dice, category);
  } else {
    return monteCarlo(dice, category);
  }
}
```

**Test:**

```typescript
test('determinism guarantee', () => {
  const dice = [3, 3, 5, 5, 6];
  const category = 'full_house';
  
  // Run 100 times
  const results = Array(100).fill(null).map(() =>
    calculateProbability(dice, category)
  );
  
  // All results must be identical
  const allSame = results.every(r => r === results[0]);
  expect(allSame).toBe(true);
});
```

### 8.5 Cache Consistency Guarantee

**Requirement:** Cached values match fresh calculations

```typescript
class CacheValidator {
  async validateCacheEntry(
    key: string,
    cachedValue: any
  ): Promise<void> {
    const fresh = await computeFresh(key);
    
    if (!deepEqual(cachedValue, fresh)) {
      // Log discrepancy
      logger.error('Cache inconsistency', {
        key,
        cached: cachedValue,
        fresh
      });
      
      // Invalidate cache
      await cache.delete(key);
      
      throw new CacheInconsistencyError(
        `Cached value for ${key} does not match fresh calculation`
      );
    }
  }
}
```

### 8.6 Event Ordering Guarantee

**Requirement:** Events are totally ordered by timestamp

```typescript
function validateEventOrdering(events: GameEvent[]): void {
  for (let i = 1; i < events.length; i++) {
    if (events[i].timestamp < events[i-1].timestamp) {
      throw new InvariantViolation(
        `Event ordering violated at index ${i}: ` +
        `${events[i].timestamp} < ${events[i-1].timestamp}`
      );
    }
  }
  
  // Additionally: turn numbers must be sequential
  const turnNumbers = events
    .filter(e => e.eventType === 'score')
    .map(e => e.turnNumber);
  
  for (let i = 1; i < turnNumbers.length; i++) {
    if (turnNumbers[i] !== turnNumbers[i-1] + 1) {
      throw new InvariantViolation(
        `Turn numbers not sequential: ${turnNumbers[i-1]} → ${turnNumbers[i]}`
      );
    }
  }
}
```

---

## 9. Performance & Scalability

### 9.1 Latency Breakdown

**Target: P95 < 100ms end-to-end**

```
User Action (dice roll)
    ↓
[Frontend] Capture state (1ms)
    ↓
[WASM] Calculate probabilities (15ms P95)
    ↓
[Frontend] Update UI (5ms)
    ↓
[Network] Send to backend (20ms P95)
    ↓
[API Gateway] Route request (2ms)
    ↓
[Decision Analyzer] Calculate EV (30ms P95)
    ↓
[Database] Record event (10ms P95)
    ↓
[Network] Return response (20ms P95)
    ↓
[Frontend] Display feedback (5ms)
    ↓
Total: 108ms (exceeds target by 8ms)
```

**Optimization Strategies:**

1. **Async event recording** — Don't wait for DB write
   - Saves 10ms
   - New total: 98ms ✓

2. **Pre-computed EV tables** — Cache common states
   - Reduces Decision Analyzer to 5ms
   - New total: 73ms ✓

3. **Edge computing** — Deploy WASM + cache near users
   - Reduces network to 5ms
   - New total: 53ms ✓

### 9.2 Throughput Targets

**Phase 1 (100 concurrent games):**
- 100 games × 13 turns × 3 rolls = 3,900 calculations/hour
- ~1.1 requests/second
- Single server easily handles

**Phase 2 (10,000 concurrent games):**
- 10,000 games × 13 turns × 3 rolls = 390,000 calculations/hour
- ~108 requests/second
- Need: 3-4 servers with load balancing

**Scalability Strategy:**

```
┌─────────────┐
│   Cloudflare│
│   (Global)  │
└──────┬──────┘
       │
   ┌───▼───┐
   │ Load  │
   │Balance│
   └───┬───┘
       │
   ┌───┴───┬────────┬────────┐
   │       │        │        │
┌──▼──┐ ┌──▼──┐ ┌──▼──┐  ┌──▼──┐
│API-1│ │API-2│ │API-3│  │API-4│
└──┬──┘ └──┬──┘ └──┬──┘  └──┬──┘
   │       │        │        │
   └───────┴────────┴────────┘
           │
      ┌────▼────┐
      │ Postgres│
      │ (Primary│
      └────┬────┘
           │
      ┌────▼────┐
      │ Postgres│
      │ (Replica│
      └─────────┘
```

### 9.3 Caching Strategy

**Three-Tier Cache:**

1. **Client WASM Cache** (70K pre-computed states)
   - Hit rate: 80%
   - Latency: 3ms
   - Storage: 5MB

2. **Redis Cache** (Hot server-side)
   - Hit rate: 15% (of cache misses)
   - Latency: 5ms
   - TTL: 1 hour

3. **Postgres Lookup Table**
   - Hit rate: 5% (of cache misses)
   - Latency: 10ms
   - Permanent storage

**Overall Cache Hit Rate:** 80% + 20%×15% + 20%×85%×5% = 84%

**Cache Invalidation:**
- Version all cached data: `state_v1`, `state_v2`
- TTL-based expiration for safety
- Explicit invalidation on schema changes

### 9.4 Resource Requirements

**Per Server Instance:**

| Resource | Requirement | Notes |
|----------|-------------|-------|
| CPU | 2 cores | 80% avg utilization |
| RAM | 4 GB | 2GB app, 2GB cache |
| Disk | 20 GB | Logs + temp storage |
| Network | 100 Mbps | 99th percentile |

**Database:**

| Metric | Requirement |
|--------|-------------|
| Storage | 100 GB / 100K games |
| IOPS | 1000 sustained |
| Connections | 100 concurrent |
| Replication | 1 read replica |

**Cost Estimate (Phase 1):**
- Compute: $50/month (2 servers)
- Database: $30/month (managed Postgres)
- CDN: $10/month (WASM + assets)
- **Total: $90/month**

---

## 10. Security & Fair Play

### 10.1 Client Integrity

**Problem:** Users could modify WASM to calculate fake probabilities

**Solution: Subresource Integrity (SRI)**

```html
<script 
  type="module" 
  src="https://cdn.dicee.app/engine-v1.0.0.js"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
  crossorigin="anonymous">
</script>
```

**Verification:** Server cross-checks critical calculations

```typescript
// Client sends calculation result
POST /v1/verify-calculation
{
  "dice": [5,5,5,2,6],
  "probability": 0.1667,
  "clientSignature": "hash-of-inputs"
}

// Server re-calculates and compares
if (Math.abs(serverProbability - clientProbability) > 0.001) {
  flagPotentialTampering(userId);
}
```

### 10.2 Deterministic Seeds (Anti-Cheat)

**Requirement:** All probability calculations use deterministic methods, not random sampling in production

```typescript
// ✅ CORRECT: Deterministic
function calculateProbability(dice: number[]): number {
  return exactCombinatorics(dice);
}

// ❌ INCORRECT: Allows client manipulation
function calculateProbability(dice: number[]): number {
  Math.seedrandom(clientProvidedSeed);  // ❌ Client controls randomness
  return monteCarlo(dice, 10000);
}
```

### 10.3 Rate Limiting

**Prevent Abuse:**

```typescript
// Per-user rate limits
const rateLimits = {
  '/probabilities': '100 requests / minute',
  '/decision': '50 requests / minute',
  '/simulate': '10 requests / minute',  // Expensive
  '/game': '1000 requests / hour'       // Gameplay actions
};

// Implementation (Redis)
async function checkRateLimit(
  userId: string,
  endpoint: string
): Promise<boolean> {
  const key = `ratelimit:${userId}:${endpoint}`;
  const count = await redis.incr(key);
  
  if (count === 1) {
    await redis.expire(key, 60);  // 1 minute window
  }
  
  return count <= getRateLimitForEndpoint(endpoint);
}
```

### 10.4 Fair Play Monitoring

**Anomaly Detection:**

```typescript
interface PlayerBehaviorProfile {
  avgDecisionTime: number;              // ~3-10 seconds typical
  optimalDecisionRate: number;          // 40-80% typical
  calculationRequestRate: number;       // 1-5 per roll typical
  
  // Red flags
  suspiciousPatterns: {
    alwaysOptimal: boolean;             // >98% optimal (bot?)
    instantDecisions: boolean;          // <100ms consistently
    perfectPredictions: boolean;        // Always predicts exact probability
  };
}

async function detectCheating(
  playerId: string
): Promise<boolean> {
  const profile = await getPlayerProfile(playerId);
  
  const redFlags = [
    profile.optimalDecisionRate > 0.98,
    profile.avgDecisionTime < 0.1,
    profile.suspiciousPatterns.perfectPredictions
  ];
  
  return redFlags.filter(Boolean).length >= 2;
}
```

### 10.5 Privacy & Data Protection

**Principles:**
- No PII in statistical telemetry
- Player IDs are UUIDs (not emails)
- Game events contain no sensitive data
- Analytics are aggregated and anonymized

**GDPR Compliance:**
```typescript
// Right to deletion
async function deletePlayerData(playerId: string): Promise<void> {
  // Anonymize events (keep for research)
  await db.query(
    'UPDATE game_events SET player_id = $1 WHERE player_id = $2',
    ['anonymous', playerId]
  );
  
  // Delete profile
  await db.query('DELETE FROM player_profiles WHERE id = $1', [playerId]);
  
  // Clear cache
  await redis.del(`profile:${playerId}`);
}
```

---

## 11. Testing & Validation Strategy

### 11.1 Unit Testing

**Coverage Target:** >95% for core algorithms

**Test Categories:**

```typescript
describe('Probability Calculations', () => {
  // Correctness tests
  test('known probability values', () => {
    expect(P([1,1,1,1,1], 'dicee')).toBe(1.0);
    expect(P([5,5,5,2,6], 'full_house')).toBeCloseTo(1/6);
    expect(P([1,2,3,4,6], 'large_straight')).toBe(0);
  });
  
  // Property-based tests
  test('probabilities sum to ≤1', () => {
    fc.assert(
      fc.property(randomDiceState(), (dice) => {
        const probs = calculateAll(dice);
        return Object.values(probs).reduce((a,b) => a+b, 0) <= 1.0;
      })
    );
  });
  
  // Edge cases
  test('handles all dice kept', () => {
    const p = P([3,3,3,3,3], [T,T,T,T,T], 'dicee');
    expect(p).toBe(1.0);  // Already achieved
  });
});
```

### 11.2 Integration Testing

**End-to-End Flow:**

```typescript
describe('Statistical Engine Integration', () => {
  test('complete decision flow', async () => {
    const engine = new StatisticalEngine();
    
    // 1. Calculate probabilities
    const probs = await engine.calculateProbabilities({
      dice: [5,5,5,2,6],
      keptMask: [true, true, true, false, false],
      rollsRemaining: 1
    });
    
    expect(probs.fullHouse.value).toBeGreaterThan(0);
    
    // 2. Get recommendation
    const rec = await engine.getRecommendation({
      gameState: buildGameState(),
      explanationDepth: 'detailed'
    });
    
    expect(rec.expectedValue).toBeDefined();
    expect(rec.reasoning).toBeTruthy();
    
    // 3. Evaluate decision
    const eval = await engine.evaluateDecision({
      gameState: buildGameState(),
      chosenCategory: 'full_house',
      timeToDecision: 3500
    });
    
    expect(eval.quality).toBeDefined();
  });
});
```

### 11.3 Validation Against Reference

**Cross-Check with Known Solutions:**

```typescript
// Published optimal Dicee strategies
import { optimalStrategyReference } from './reference-data';

describe('Optimal Strategy Validation', () => {
  test('matches published EV tables', () => {
    for (const scenario of optimalStrategyReference) {
      const ourEV = calculateOptimalEV(scenario.state);
      const refEV = scenario.expectedValue;
      
      // Within 0.5 points (published data has rounding)
      expect(Math.abs(ourEV - refEV)).toBeLessThan(0.5);
    }
  });
});
```

### 11.4 Performance Testing

**Latency Requirements:**

```typescript
describe('Performance SLAs', () => {
  test('probability calculation <100ms P95', async () => {
    const latencies: number[] = [];
    
    for (let i = 0; i < 1000; i++) {
      const start = performance.now();
      await calculateProbabilities(randomState());
      latencies.push(performance.now() - start);
    }
    
    const p95 = percentile(latencies, 95);
    expect(p95).toBeLessThan(100);
  });
  
  test('handles 1000 requests/second', async () => {
    const requests = Array(1000).fill(null).map(() =>
      calculateProbabilities(randomState())
    );
    
    const start = performance.now();
    await Promise.all(requests);
    const duration = performance.now() - start;
    
    expect(duration).toBeLessThan(1000);
  });
});
```

### 11.5 Chaos Engineering

**Test Resilience:**

```typescript
describe('Failure Handling', () => {
  test('gracefully degrades when cache unavailable', async () => {
    // Simulate Redis failure
    await redis.disconnect();
    
    // Should still work (slower)
    const result = await calculateProbabilities(state);
    expect(result).toBeDefined();
    expect(result.computationTime).toBeGreaterThan(50);
  });
  
  test('falls back when Monte Carlo times out', async () => {
    // Simulate heavy load
    await simulateHighCPU();
    
    const rec = await getRecommendation(complexState);
    expect(rec.recommendation).toBeDefined();
    expect(rec.confidence).toBeLessThan('high');
  });
});
```

---

## 12. Implementation Roadmap

### Phase 1: Core Calculation Engine (Week 1)
**Goal:** Exact probability calculations working

- ✅ Implement scoring functions (all 13 categories)
- ✅ Single-roll probability enumeration
- ✅ Unit tests (>95% coverage)
- ✅ Basic EV calculation (terminal states)
- ✅ TypeScript implementation + validation

**Deliverables:**
- `packages/probability-core/` library
- 100+ unit tests passing
- Benchmark results documented

### Phase 2: Multi-Roll EV & Caching (Week 2)
**Goal:** Dynamic programming EV calculator

- ✅ Recursive EV with memoization
- ✅ Pre-compute lookup tables
- ✅ Decision Analyzer service (Bun)
- ✅ Redis caching integration
- ✅ Integration tests

**Deliverables:**
- `services/decision-analyzer/` API
- Lookup table generator script
- Performance benchmarks (<100ms)

### Phase 3: WASM Compilation (Week 3)
**Goal:** Client-side zero-latency engine

- ✅ Port core algorithms to Rust
- ✅ Compile to WASM
- ✅ npm package: `@dicee/probability-engine`
- ✅ Browser integration tests
- ✅ SRI hashing for security

**Deliverables:**
- WASM module (<200KB)
- CDN deployment
- Browser compatibility tests

### Phase 4: Monte Carlo & Validation (Week 3-4)
**Goal:** Heavy simulation for validation

- ✅ Numba-optimized simulator
- ✅ Confidence interval calculation
- ✅ Validation test suite
- ✅ Optional GPU acceleration

**Deliverables:**
- `services/monte-carlo/` Python service
- Cross-validation report
- Performance benchmarks

### Phase 5: Learning Tracker (Week 4-5)
**Goal:** Adaptive skill assessment

- ✅ Player skill profiling
- ✅ Decision quality tracking
- ✅ Adaptive presentation logic
- ✅ Tool unlocking system
- ✅ Analytics dashboard

**Deliverables:**
- `services/learning-tracker/` FastAPI service
- Skill assessment algorithm
- Progression tests

### Phase 6: Production Hardening (Week 5-6)
**Goal:** Deploy-ready system

- ✅ Load testing (1000 rps)
- ✅ Monitoring dashboards
- ✅ Error tracking (Sentry)
- ✅ Documentation complete
- ✅ Security audit

**Deliverables:**
- Production deployment
- Runbooks and alerts
- API documentation (OpenAPI)

---

## 13. Sample Execution Trace

### Real Example: Turn 3, Roll 2

**Initial State:**
```json
{
  "gameId": "game-123",
  "playerId": "player-alice",
  "turnNumber": 3,
  "rollNumber": 2,
  "dice": [5, 5, 5, 2, 6],
  "keptDice": [false, false, false, false, false],
  "availableCategories": [
    "ones", "twos", "fours", "sixes",
    "three_of_kind", "four_of_kind", "full_house",
    "small_straight", "large_straight", "dicee", "chance"
  ]
}
```

---

**Step 1: Player Rolls Dice**

Event recorded:
```json
{
  "id": "evt-001",
  "eventType": "roll",
  "eventVersion": "1.0.0",
  "timestamp": 1698765432100,
  "traceId": "trace-xyz",
  "gameId": "game-123",
  "playerId": "player-alice",
  "turnNumber": 3,
  "rollNumber": 2,
  "diceResult": [5, 5, 5, 2, 6],
  "keptMask": [false, false, false, false, false],
  "preRollDice": [1, 3, 5, 5, 5],
  "computationTime": 12
}
```

---

**Step 2: WASM Engine Calculates Probabilities**

Request to WASM:
```typescript
engine.calculate_probabilities(
  new Uint8Array([5, 5, 5, 2, 6]),
  new Uint8Array([0, 0, 0, 0, 0]),  // None kept yet
  1  // 1 roll remaining
)
```

Result (13ms):
```json
{
  "probabilities": {
    "full_house": {
      "value": 0.1667,
      "asPercentage": "16.7%",
      "asFraction": "1/6",
      "confidence": 1.0,
      "isAchievable": true,
      "recommendKeep": [0, 1, 2]  // Keep the three 5s
    },
    "four_of_kind": {
      "value": 0.2778,
      "asPercentage": "27.8%",
      "asFraction": "10/36",
      "confidence": 1.0,
      "isAchievable": true,
      "recommendKeep": [0, 1, 2]
    },
    "dicee": {
      "value": 0.0278,
      "asPercentage": "2.8%",
      "asFraction": "1/36",
      "confidence": 1.0,
      "isAchievable": true,
      "recommendKeep": [0, 1, 2]
    },
    "fives": {
      "value": 1.0,
      "asPercentage": "100%",
      "confidence": 1.0,
      "isAchievable": true
    }
  },
  "computationMethod": "exact",
  "computationTime": 13,
  "cacheHit": false
}
```

---

**Step 3: Player Hovers "Full House"**

Event recorded:
```json
{
  "id": "evt-002",
  "eventType": "hover",
  "timestamp": 1698765433200,
  "traceId": "trace-xyz",
  "categoryHovered": "full_house",
  "hoverDuration": 1200,
  "wouldScore": 25,
  "currentEV": 4.17,  // 25 × 0.1667
  "isOptimal": false
}
```

---

**Step 4: Decision Analyzer Calculates EV**

Request:
```json
POST /v1/decision
{
  "gameState": {
    "dice": [5, 5, 5, 2, 6],
    "rollsRemaining": 1,
    "availableCategories": ["full_house", "fives", "chance", ...]
  },
  "explanationDepth": "detailed"
}
```

Decision Analyzer logic:
```typescript
// Option 1: Score Fives now
EV(fives) = 15  // Guaranteed

// Option 2: Score Chance now  
EV(chance) = 28  // Guaranteed (5+5+5+2+6)

// Option 3: Reroll for Full House
EV(full_house | keep [5,5,5], reroll [2,6]) = 
  P(get pair) × 25 + P(fail) × score_later
  = 0.1667 × 25 + 0.8333 × 0
  = 4.17

// Option 4: Reroll for Four-of-a-Kind
EV(4oak | keep [5,5,5], reroll [2,6]) =
  P(get another 5) × 27 + P(fail) × 0
  = 0.2778 × 27 + 0.7222 × 0
  = 7.5

// Optimal: Score Chance (EV = 28)
```

Response (42ms):
```json
{
  "status": "success",
  "recommendation": {
    "action": "score",
    "category": "chance",
    "expectedValue": 28.0,
    "confidence": "high",
    "reasoning": "Guaranteed 28 points by scoring Chance now. Rerolling risks losing value for uncertain category achievements.",
    "alternatives": [
      {
        "category": "fives",
        "expectedValue": 15.0,
        "evDifference": -13.0,
        "reasoning": "Scores 15 points (three 5s) but leaves 13 points on table"
      },
      {
        "category": "four_of_kind",
        "expectedValue": 7.5,
        "evDifference": -20.5,
        "reasoning": "27.8% chance of rolling another 5, but risky"
      }
    ],
    "learningTip": "Chance is most valuable with high dice totals and no clear category fit"
  },
  "computationTime": 42,
  "traceId": "trace-xyz"
}
```

---

**Step 5: Player Chooses "Fives" (Suboptimal)**

Event recorded:
```json
{
  "id": "evt-003",
  "eventType": "score",
  "timestamp": 1698765436800,
  "traceId": "trace-xyz",
  "gameId": "game-123",
  "playerId": "player-alice",
  "turnNumber": 3,
  "chosenCategory": "fives",
  "pointsEarned": 15,
  
  "expectedValue": 15.0,
  "optimalCategory": "chance",
  "optimalEV": 28.0,
  "evDifference": -13.0,
  "decisionQuality": "suboptimal",
  
  "timeToDecision": 3700,
  "categoriesConsidered": ["full_house", "fives", "chance"],
  "backtrackCount": 1,
  "hintRequested": false
}
```

---

**Step 6: Learning Tracker Updates Skill Profile**

Async operation (50ms):
```python
await learning_tracker.record_decision({
  "player_id": "player-alice",
  "ev_difference": -13.0,
  "decision_quality": "suboptimal",
  "category_used": "fives"
})

# Update running statistics
profile = await get_player_profile("player-alice")
profile.decision_quality_ewma = 0.9 × profile.decision_quality_ewma + 0.1 × (-13.0)
profile.category_mastery["fives"] -= 2  # Suboptimal use
```

---

**Step 7: Feedback Displayed to Player**

```json
{
  "status": "success",
  "evaluation": {
    "quality": "suboptimal",
    "evDifference": -13.0,
    "feedback": "You scored 15 points in Fives, but Chance would have earned 28 points (13 more). Consider using Chance for high-value mixed dice.",
    "missedPoints": 13,
    "learningTip": "Fives is better saved for rolls with four or five 5s."
  }
}
```

---

**Total Execution Time:**
- WASM calculation: 13ms
- Decision analysis: 42ms
- Event recording: 8ms (async)
- Learning tracker: 50ms (async, non-blocking)
- **User-perceived latency: 55ms** ✓

---

## 14. Research References

### 14.1 Probability Theory Foundations

1. **Ross, S.** (2019). *A First Course in Probability* (10th ed.). Pearson.
   - Chapters 2-4: Combinatorics and conditional probability
   - Chapter 7: Expected value and variance

2. **Feller, W.** (1968). *An Introduction to Probability Theory and Its Applications* (3rd ed.). Wiley.
   - Volume 1, Chapter 2: Dice problems and combinatorics

3. **Knuth, D.** (1997). *The Art of Computer Programming, Vol. 2: Seminumerical Algorithms* (3rd ed.). Addison-Wesley.
   - Section 3.3: Random number generation
   - Section 1.2.6: Binomial coefficients

### 14.2 Game Theory & Optimal Play

4. **Sutton, R. & Barto, A.** (2018). *Reinforcement Learning: An Introduction* (2nd ed.). MIT Press.
   - Chapter 3: Finite Markov decision processes
   - Chapter 4: Dynamic programming

5. **Bellman, R.** (1957). *Dynamic Programming*. Princeton University Press.
   - Original formulation of Bellman equations

6. **Russell, S. & Norvig, P.** (2020). *Artificial Intelligence: A Modern Approach* (4th ed.). Pearson.
   - Chapter 17: Making simple decisions (MDPs)

### 14.3 Dicee-Specific Research

7. **Glenn, J.** (2006). "Optimal Strategy in Dicee." *College Mathematics Journal*, 37(5), 367-371.
   - Exhaustive dynamic programming solution
   - Expected value tables for optimal play

8. **Verhoeff, T. & van den Boom, R.** (2004). "Dicee: A Large Stochastic Multiple-Choice Knapsack Problem." *TU Eindhoven Technical Report*.
   - Computational complexity analysis

9. **Woodward, J.** (2018). "Solving Dicee with Dynamic Programming and Memoization." *Journal of Computing Sciences in Colleges*, 33(4), 12-19.

### 14.4 Educational Technology

10. **Papert, S.** (1980). *Mindstorms: Children, Computers, and Powerful Ideas*. Basic Books.
    - Constructionist learning theory
    - Learning through making decisions

11. **Gee, J.** (2003). *What Video Games Have to Teach Us About Learning and Literacy*. Palgrave Macmillan.
    - Game-based learning principles

12. **Koedinger, K. & Corbett, A.** (2006). "Cognitive Tutors: Technology Bringing Learning Sciences to the Classroom." *The Cambridge Handbook of the Learning Sciences*.
    - Adaptive learning systems

### 14.5 Statistical Computing

13. **Metropolis, N. & Ulam, S.** (1949). "The Monte Carlo Method." *Journal of the American Statistical Association*, 44(247), 335-341.
    - Original Monte Carlo paper

14. **Gentle, J.** (2009). *Computational Statistics*. Springer.
    - Chapter 2: Monte Carlo methods
    - Chapter 5: Markov chain Monte Carlo

### 14.6 Software Architecture

15. **Fowler, M.** (2017). *Event Sourcing*. martinfowler.com
    - Event-driven architecture patterns

16. **Newman, S.** (2021). *Building Microservices* (2nd ed.). O'Reilly.
    - Microservices design patterns
    - Failure handling strategies

---

## 15. Appendices

### Appendix A: Probability Calculation Examples

**Example 1: Full House Probability**

Given: `[5, 5, 5, 2, 6]`, keep `[T, T, T, F, F]`

Need: Any pair (2,2), (6,6), or any matching pair

```
Total outcomes when rolling 2 dice: 6² = 36

Favorable outcomes:
- Rolling (1,1): 1 way
- Rolling (2,2): 1 way
- Rolling (3,3): 1 way
- Rolling (4,4): 1 way
- Rolling (5,5): 1 way
- Rolling (6,6): 1 way

Total favorable: 6

P(Full House) = 6/36 = 1/6 ≈ 16.67%
```

---

**Example 2: Dicee Continuation**

Given: `[3, 3, 3, 3, 4]`, keep `[T, T, T, T, F]`

Need: Roll a 3

```
Total outcomes: 6
Favorable outcomes: 1 (rolling a 3)

P(Dicee) = 1/6 ≈ 16.67%
```

---

### Appendix B: EV Calculation Example

**Scenario:** `[5, 5, 5, 2, 6]`, 1 roll left

**Available categories:** Fives, Chance, Full House

**EV Calculations:**

1. **Score Fives now:**
   ```
   EV = 15 (guaranteed)
   ```

2. **Score Chance now:**
   ```
   EV = 28 (guaranteed: 5+5+5+2+6)
   ```

3. **Reroll for Full House:**
   ```
   Keep: [5,5,5]
   Reroll: [2,6]
   
   P(get pair) = 6/36 = 1/6
   Score if success = 25
   Score if fail = 0 (must use Chance later for ~14 pts avg)
   
   EV = (1/6 × 25) + (5/6 × 0) = 4.17
   ```

**Optimal Decision:** Score Chance (EV = 28)

**If player chooses Fives:**
- EV difference: 15 - 28 = -13 points
- Decision quality: "Suboptimal"

---

### Appendix C: Service Health Checks

**Liveness Probes:**

```yaml
# Probability Engine (WASM)
GET /health/live
Response: { "status": "ok", "version": "1.0.0" }

# Decision Analyzer
GET /health/live
Response: { "status": "ok", "uptime": 3600, "version": "1.2.0" }

# Monte Carlo Simulator
GET /health/live
Response: { "status": "ok", "gpu_available": true }

# Learning Tracker
GET /health/live
Response: { "status": "ok", "db_connected": true }
```

**Readiness Probes:**

```yaml
# Decision Analyzer
GET /health/ready
Response: {
  "status": "ready",
  "dependencies": {
    "redis": "connected",
    "postgres": "connected",
    "wasm_engine": "loaded"
  }
}
```

---

### Appendix D: Error Codes Reference

| Code | Description | HTTP Status | Resolution |
|------|-------------|-------------|------------|
| `INVALID_DICE_STATE` | Malformed dice input | 400 | Fix request format |
| `INVALID_KEPT_MASK` | Kept mask length ≠ 5 | 400 | Fix request format |
| `INVALID_CATEGORY` | Unknown category name | 400 | Use valid category |
| `CATEGORY_UNAVAILABLE` | Already scored | 409 | Choose different |
| `COMPUTATION_TIMEOUT` | Exceeded deadline | 504 | Retry or simplify |
| `SERVICE_UNAVAILABLE` | Backend down | 503 | Retry with backoff |
| `RATE_LIMIT_EXCEEDED` | Too many requests | 429 | Wait and retry |
| `CACHE_INCONSISTENCY` | Cache vs. fresh mismatch | 500 | Invalidate cache |
| `INVARIANT_VIOLATION` | Math invariant broken | 500 | Report bug |

---

### Appendix E: Monitoring Metrics

**Key Metrics to Track:**

```yaml
# Performance
- probability_calculation_latency_ms (P50, P95, P99)
- decision_analysis_latency_ms (P50, P95, P99)
- monte_carlo_duration_ms (P50, P95, P99)
- api_response_time_ms (P50, P95, P99)

# Throughput
- requests_per_second (by endpoint)
- calculations_per_second
- cache_hit_rate (percentage)
- cache_miss_rate (percentage)

# Quality
- calculation_accuracy_delta (vs. reference)
- ev_calculation_errors (count)
- invariant_violations (count)
- cache_inconsistencies (count)

# Business
- active_games (gauge)
- games_completed_per_hour (rate)
- decision_quality_avg (by skill level)
- tool_unlocks_per_day (rate)
```

---

**Document Status:** ✅ RFC Ready for Review  
**Next Steps:**
1. Circulate for team review
2. Address feedback and update
3. Final approval → Begin Phase 1 implementation
4. Create RFC-002 (Educational Alignment)

---

**Related Documents:**
- RFC-002: Educational Alignment & Curriculum Integration (TBD)
- RFC-003: Data Contracts & Event Schema (TBD)
- RFC-004: Frontend-Backend Integration Contract (TBD)
- RFC-005: Adaptive Learning Model Specification (TBD)
- RFC-006: Security & Privacy Architecture (TBD)

========================================
FILE: rfc-002-ui-ux-canvas.md
========================================

# RFC-002: UI/UX Canvas Design
**Project:** Dicee — Educational Probability Platform  
**RFC Status:** Review → Revision → Accepted  
**Version:** 1.1  
**Date:** October 25, 2025  
**Authors:** Design & Engineering Team  
**Reviewers:** Technical Review Complete

---

## Document Status & Versioning

| Version | Date | Changes | Status |
|---------|------|---------|--------|
| 1.0 | 2025-10-25 | Initial UI/UX architecture specification | Superseded |
| 1.1 | 2025-10-25 | Post-review revision: v1/v2 phasing, MVS focus, Neo-Brutalist fixes | Current |

**Review Summary:** Strong Accept with Revisions. Core thesis ("stats as superpowers") is sound. Revised to focus on Minimum Viable Statistics (MVS) for v1.0, deferred complex visualizations to v2.0, simplified complexity system to manual setting, fixed Neo-Brutalist contradictions, and adjusted mobile layout proportions.

**Related RFCs:**
- RFC-001: Statistical Engine Architecture ✅
- RFC-003: Data Contracts & Event Schema (TBD)
- RFC-004: Game Loop & Mechanics (TBD)
- RFC-005: Educational Content System (TBD)

**Dependencies:**
- Requires RFC-001 statistical engine for data sources
- Informs RFC-004 game mechanics implementation

---

## Abstract

This RFC specifies the user interface and user experience architecture for Dicee, focusing on the critical challenge: **making statistics feel like superpowers, not homework**. The design employs a Neo-brutalist aesthetic with a revolutionary **Statistical Heads-Up Display (HUD)** that overlays probabilistic information contextually, adapting complexity based on player skill level through progressive disclosure.

**Core Innovation:** Transform the UI canvas into a multi-layered statistical instrument where information density, visual prominence, and interaction patterns scale dynamically with player mastery, creating an experience where probability becomes intuitive through embodied play.

---

## Table of Contents

1. [Design Philosophy & Principles](#1-design-philosophy--principles)
2. [Canvas Architecture & Layout System](#2-canvas-architecture--layout-system)
3. [Neo-Brutalist Design Language](#3-neo-brutalist-design-language)
4. [Statistical HUD System](#4-statistical-hud-system)
5. [Progressive Complexity Layers](#5-progressive-complexity-layers)
6. [Component Specifications](#6-component-specifications)
7. [Interaction Patterns & Gestures](#7-interaction-patterns--gestures)
8. [Responsive Adaptation Strategy](#8-responsive-adaptation-strategy)
9. [Animation & Motion Design](#9-animation--motion-design)
10. [Accessibility & Inclusive Design](#10-accessibility--inclusive-design)
11. [Performance Budget](#11-performance-budget)
12. [Implementation Roadmap](#12-implementation-roadmap)
13. [Design Validation Metrics](#13-design-validation-metrics)
14. [Appendices](#14-appendices)

---

## 1. Design Philosophy & Principles

### 1.1 Core Design Thesis

**Statistics Must Feel Like Superpowers**

Traditional educational interfaces treat statistics as supplementary information—tooltips, sidebar panels, post-hoc reports. Dicee inverts this relationship: **probability is the primary interface layer**, and the game components (dice, scorecard) are the substrate through which statistical thinking manifests.

**Analogy:** Just as fighter pilots use HUDs that overlay flight data on their field of vision, Dicee players navigate probability space with statistical overlays that enhance rather than obstruct their decision-making.

### 1.2 Design Principles

**Principle 1: Ambient Awareness**  
Statistics exist in the visual periphery until needed. Players develop intuition through continuous exposure without conscious attention.

**Principle 2: Progressive Revelation**  
The interface starts minimal and grows more sophisticated as players demonstrate mastery. Complexity unlocks, never overwhelms.

**Principle 3: Honest Aesthetics**  
Neo-brutalist design communicates "this is a tool for learning" through raw, functional beauty. No decoration masks statistical reality.

**Principle 4: Contextual Intelligence**  
Every UI element adapts to game state, player skill, and moment-to-moment context. No static layouts.

**Principle 5: Tactile Feedback**  
Every interaction generates immediate, satisfying feedback. Players feel the weight of decisions through visual and haptic response.

### 1.3 User Experience Goals

**For Beginners (Sessions 1-10):**
- "I understand what each number means"
- "I can see which move is best without feeling lectured"
- "The game feels smooth and responsive"

**For Intermediate (Sessions 11-50):**
- "I'm starting to predict probabilities before I see them"
- "I understand why certain moves are better"
- "I can experiment with different strategies confidently"

**For Advanced (Sessions 51+):**
- "I think in terms of expected value naturally"
- "I can read the statistical landscape at a glance"
- "The interface gets out of my way and lets me focus"

### 1.4 Anti-Patterns to Avoid

❌ **Statistical Clutter:** Too many numbers create cognitive overload  
❌ **Delayed Feedback:** Waiting for calculations breaks flow state  
❌ **Inconsistent Metaphors:** Mixed visual languages confuse understanding  
❌ **Patronizing Simplification:** Dumbing down insults player intelligence  
❌ **Modal Dialogs:** Blocking interactions disrupts gameplay rhythm  

---

## 2. Canvas Architecture & Layout System

### 2.1 Information Density Zones

The canvas is divided into **semantic zones** with distinct information density and interaction priority.

```
Mobile Portrait (375×667 baseline)
┌─────────────────────────────────────┐
│  Zone 1: Action Layer (30% height)  │
│  ┌───────────────────────────────┐  │
│  │   Dice Tray (Compact)         │  │
│  │   [🎲] [🎲] [🎲]             │  │
│  │   [🎲] [🎲]                   │  │
│  │   Roll • 2/3                  │  │
│  │                               │  │
│  │   Statistical HUD (Overlay)   │  │
│  │   ↳ Category Heat Map         │  │
│  └───────────────────────────────┘  │
├─────────────────────────────────────┤
│  Zone 2: Decision Layer (60%)      │
│  ┌───────────────────────────────┐  │
│  │   Scorecard (Scrollable)      │  │
│  │   Upper Section               │  │
│  │   ⚀ Ones    [  3] ✓          │  │
│  │   ⚁ Twos    [   ] 23%         │  │
│  │   ⚂ Threes  [  9] ✓          │  │
│  │   ⚃ Fours   [   ] 15%         │  │
│  │   ⚄ Fives   [   ] 100%        │  │
│  │   ⚅ Sixes   [   ] 8%          │  │
│  │   Bonus: 18/63                │  │
│  │                               │  │
│  │   Lower Section               │  │
│  │   🏠 Full House [  ] 16.7%    │  │
│  │   ...                         │  │
│  └───────────────────────────────┘  │
├─────────────────────────────────────┤
│  Zone 3: Context Layer (10%)       │
│  ┌───────────────────────────────┐  │
│  │ 👤 Your Turn  Stats:ON  💬    │  │
│  │ Turn 5/13 • Score: 145        │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

**Zone Characteristics:**

| Zone | Density | Interaction | Sticky | Purpose | v1 Height |
|------|---------|-------------|--------|---------|-----------|
| Action | High | Primary | Yes | Execute rolls, manipulate dice | 30% |
| Decision | Medium | Secondary | No | Choose scoring categories | 60% |
| Context | Low | Tertiary | Yes | Game state, social features | 10% |

**Height Rationale:**
- **30% Action Layer:** Compact dice grid (3+2 layout) ensures full Upper Section visible without scrolling
- **60% Decision Layer:** Shows 7-8 categories simultaneously on most devices, reducing scroll friction
- **10% Context:** Minimal but persistent game state

### 2.2 Desktop Adaptive Layout

Desktop expands zones horizontally for always-visible context:

```
Desktop (1440×900 baseline)
┌────────────────┬──────────────────────┬────────────────┐
│  Action Zone   │   Decision Zone      │  Analytics     │
│  (30% width)   │   (45% width)        │  Zone (25%)    │
│                │                      │                │
│  ┌──────────┐  │  ┌────────────────┐  │  ┌──────────┐  │
│  │  Dice    │  │  │  Full Scorecard│  │  │  EV Chart│  │
│  │  Tray    │  │  │  (No scroll)   │  │  │  ────────│  │
│  │  [🎲][🎲]│  │  │  Upper:        │  │  │  Chance  │  │
│  │  [🎲][🎲]│  │  │  • Ones   [3]  │  │  │  28 pts  │  │
│  │  [🎲]    │  │  │  • Twos   [ ]  │  │  │  ████████│  │
│  └──────────┘  │  │  • Threes [9]  │  │  │          │  │
│                │  │  ...           │  │  │  Fives   │  │
│  ┌──────────┐  │  │                │  │  │  15 pts  │  │
│  │  Roll    │  │  │  Lower:        │  │  │  ████    │  │
│  │  Button  │  │  │  • 3oak  [ ]   │  │  │          │  │
│  │  2 left  │  │  │  • FullHs[ ]   │  │  └──────────┘  │
│  └──────────┘  │  │  ...           │  │                │
│                │  └────────────────┘  │  Probability  │
│  Stats HUD:    │                      │  Distribution │
│  P(Full) 16.7% │  Opponents:          │  Heat Map     │
│  EV: +4.2      │  Alice • 156         │               │
│                │  Bob   • 142         │               │
└────────────────┴──────────────────────┴────────────────┘
```

### 2.3 Zone Transition Rules

**Mobile ↔ Tablet:**
- Zones expand proportionally
- Stats HUD gains more persistent elements
- Decision Zone shows more categories simultaneously

**Tablet ↔ Desktop:**
- Three-zone layout becomes three-column
- Analytics Zone appears (hidden on mobile)
- Opponent states always visible

**Breakpoints:**

| Device | Width | Layout |
|--------|-------|--------|
| Mobile (Portrait) | 320-480px | Single column, zones stack |
| Mobile (Landscape) | 568-844px | Two column hybrid |
| Tablet | 768-1024px | Two column, expanded zones |
| Desktop | 1280px+ | Three column, full analytics |

---

## 3. Neo-Brutalist Design Language

### 3.1 Visual Principles

**Brutalism:** Raw, honest materials. Function exposed, not hidden.  
**Neo:** Modern refinement. Accessibility and usability retained.

**Core Tenets:**
1. **Hard Edges** — No rounded corners, no soft shadows
2. **High Contrast** — Black/white primary, single accent color
3. **Visible Structure** — Borders delineate, grids organize
4. **Typography as UI** — Text is functional, not decorative
5. **Honest Interactivity** — Buttons look like buttons

### 3.2 Color System

**Primary Palette:**

```css
--color-background: #FAFAFA;    /* Off-white, reduces eye strain */
--color-surface: #FFFFFF;       /* Pure white for cards */
--color-border: #000000;        /* Hard black lines */
--color-text: #0A0A0A;          /* Near-black for text */

--color-accent: #FFD700;        /* Electric gold for interactions */
--color-accent-dark: #B8860B;   /* Darker gold for hover */

--color-success: #10B981;       /* Green for optimal decisions */
--color-warning: #F59E0B;       /* Amber for acceptable moves */
--color-danger: #EF4444;        /* Red for suboptimal moves */

--color-disabled: #9CA3AF;      /* Gray for inactive elements */
```

**Semantic Colors:**

```css
/* Statistical quality indicators */
--color-optimal: var(--color-success);
--color-good: #22C55E;
--color-acceptable: var(--color-warning);
--color-suboptimal: #F97316;
--color-poor: var(--color-danger);

/* Probability confidence */
--color-certain: var(--color-accent);
--color-likely: #FCD34D;
--color-uncertain: #FDE68A;
```

### 3.3 Typography System

**Font Stack:**

```css
--font-sans: 'Inter Variable', 'SF Pro', -apple-system, system-ui, sans-serif;
--font-mono: 'JetBrains Mono', 'SF Mono', 'Courier New', monospace;
```

**Type Scale (Major Third: 1.250):**

| Level | Size | Weight | Use Case |
|-------|------|--------|----------|
| Display | 48px | 700 | Game over, Dicee celebration |
| H1 | 38px | 700 | Section headers |
| H2 | 30px | 600 | Category groups |
| H3 | 24px | 600 | Zone titles |
| Body | 16px | 400 | Standard text |
| Small | 14px | 400 | Secondary info |
| Tiny | 12px | 500 | Metadata, timestamps |
| Mono | 14px | 500 | Scores, probabilities |

**Font Variations:**

```css
/* Tabular numbers for score alignment */
.score {
  font-variant-numeric: tabular-nums;
  font-feature-settings: 'tnum' 1;
}

/* Statistical emphasis */
.probability {
  font-family: var(--font-mono);
  letter-spacing: 0.5px;
}
```

### 3.4 Spacing System

**8px base unit (rem-based for accessibility):**

```css
--space-1: 0.5rem;  /* 8px */
--space-2: 1rem;    /* 16px */
--space-3: 1.5rem;  /* 24px */
--space-4: 2rem;    /* 32px */
--space-5: 3rem;    /* 48px */
--space-6: 4rem;    /* 64px */
```

**Layout Grid:**
- Base: 8px grid
- Components snap to 8px increments
- Responsive: scales with viewport (fluid typography)

### 3.5 Border & Stroke System

**All borders are solid black:**

```css
--border-thin: 1px solid var(--color-border);
--border-medium: 2px solid var(--color-border);
--border-thick: 3px solid var(--color-border);
--border-heavy: 4px solid var(--color-border);
```

**Hierarchy through weight:**
- Thin (1px): Internal dividers, table lines
- Medium (2px): Component containers, cards
- Thick (3px): Active/selected states
- Heavy (4px): Primary actions, focus indicators

### 3.6 Component Patterns

**Button:**

```css
.button {
  background: var(--color-accent);
  border: var(--border-thick);
  color: var(--color-text);
  padding: var(--space-2) var(--space-3);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  
  /* NO border-radius, NO box-shadow */
  transition: background 150ms ease, transform 100ms ease;
}

.button:hover {
  background: var(--color-accent-dark);
  transform: translateY(-2px);
}

.button:active {
  transform: translateY(0);
}
```

**Card:**

```css
.card {
  background: var(--color-surface);
  border: var(--border-medium);
  padding: var(--space-3);
  
  /* Sharp corners, visible structure */
}
```

**Dice:**

```css
.die {
  width: 60px;
  height: 60px;
  background: var(--color-surface);
  border: var(--border-thick);
  
  /* Pips as geometric shapes */
  display: grid;
  place-items: center;
}

.die.held {
  border-color: var(--color-accent);
  border-width: 4px;
  
  /* Subtle background glow */
  background: linear-gradient(135deg, #FFFFFF, #FFF9E6);
}
```

---

## 4. Statistical HUD System

### 4.1 HUD Architecture Overview

The Statistical HUD is a **persistent overlay system** that provides contextual probability information without obstructing gameplay. It operates at multiple fidelity levels based on player skill and UI state.

**Version Roadmap:**
- **v1.0 (MVP):** Category Heat Map only
- **v1.1:** Add EV Differential Display
- **v2.0:** Advanced visualizations (Halos, Compass, Wave)

**Rationale:** The Category Heat Map delivers 90% of educational value with 10% of implementation complexity. It directly answers "What should I pick?" and integrates seamlessly into the existing Scorecard component. Complex visualizations are deferred to avoid scope creep.

**HUD Layers (Z-Index Stack):**

```
Layer 5: Critical Alerts (z-index: 1000)
  ↳ Game over, errors, confirmations

Layer 4: Interactive Modals (z-index: 500)
  ↳ Explanations, tutorials

Layer 3: Contextual Tooltips (z-index: 400)
  ↳ Hover explanations

Layer 2: Statistical Overlay (z-index: 300)
  ↳ Category heat map (v1.0)
  ↳ EV indicators (v1.1+)

Layer 1: Game Components (z-index: 100)
  ↳ Dice, scorecard, buttons

Layer 0: Background (z-index: 0)
  ↳ Canvas, gradients
```

### 4.2 Category Heat Map (v1.0 - PRIORITY 1)

**Purpose:** Visual scorecard overlay showing "hot" (high-value) categories

**Why This Is MVP:**
1. Directly integrates into Scorecard component (no new UI space)
2. Displays both key metrics: P(category) and EV(category)
3. Answers core question: "What's the best move?"
4. Minimal implementation complexity
5. Perfect fit for "stats hanging around every move" vision

**Visual Specification:**

```svelte
{#each categories as cat}
  <div
    class="category-row"
    style:--heat={cat.ev / maxEV}
    class:optimal={cat.isOptimal}
  >
    <span class="name">{cat.displayName}</span>
    <span class="score">{cat.currentScore ?? '—'}</span>
    
    <!-- Heat indicator (v1.0 core feature) -->
    <div
      class="heat-bar"
      style:width="{(cat.ev / maxEV) * 100}%"
    />
    
    {#if cat.probability}
      <span class="probability">{cat.probability.toFixed(1)}%</span>
    {/if}
    
    {#if cat.expectedValue && statsMode >= 2}
      <span class="ev">EV: {cat.expectedValue.toFixed(1)}</span>
    {/if}
  </div>
{/each}

<style>
  .category-row {
    position: relative;
    display: grid;
    grid-template-columns: 1fr auto auto;
    gap: var(--space-2);
    padding: var(--space-2);
    border-bottom: var(--border-thin);
  }
  
  .heat-bar {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    background: var(--color-accent);
    opacity: calc(var(--heat) * 0.3);
    pointer-events: none;
    transition: width 300ms ease, opacity 300ms ease;
  }
  
  .category-row.optimal .heat-bar {
    background: var(--color-optimal);
    opacity: 0.4;
  }
  
  .category-row:hover .heat-bar {
    opacity: calc(var(--heat) * 0.6);
  }
</style>
```

### 4.3 EV Differential Display (v1.1 - PRIORITY 2)

**Floating Indicator** showing real-time expected value difference from optimal:

**Implementation Deferred:** This feature provides high value with low complexity, but is not essential for v1.0 playability. Add in v1.1 after core gameplay validated.

```svelte
<div class="ev-differential" class:positive={evDiff >= 0}>
  <span class="value">
    {evDiff > 0 ? '+' : ''}{evDiff.toFixed(1)}
  </span>
  <span class="label">vs optimal</span>
</div>

<style>
  .ev-differential {
    position: fixed;
    top: 20px;
    right: 20px;
    
    background: var(--color-surface);
    border: var(--border-medium);
    padding: var(--space-2);
    
    font-family: var(--font-mono);
    
    transition: all 200ms ease;
  }
  
  .ev-differential.positive {
    border-color: var(--color-success);
    color: var(--color-success);
  }
  
  .ev-differential:not(.positive) {
    border-color: var(--color-danger);
    color: var(--color-danger);
  }
</style>
```

### 4.4 Advanced Visualizations (v2.0 - DEFERRED)

The following features are **explicitly deferred to v2.0** to prevent scope creep:

**Probability Halos** (Deferred)
- SVG rings around dice showing outcome distribution
- High implementation complexity
- Visual polish, not core functionality

**Decision Compass** (Deferred)
- Miniature decision tree visualization
- Requires complex SVG layout algorithm
- Educational value is incremental over heat map

**Probability Wave Visualization** (Deferred)
- Canvas-based waveform showing probability density
- Requires Canvas API and animation system
- Alternative visualization to heat map, not complementary

**Rationale for Deferral:**
These features are excellent polish and provide educational depth, but they:
1. Require significant implementation time (2-3 weeks each)
2. Do not block core gameplay or learning
3. Can be validated through user testing of v1.0 first
4. May need redesign based on actual usage patterns

**v2.0 Prioritization:**
After v1.0 user testing, prioritize these features based on:
- User feedback on "missing" statistical information
- Engagement metrics (do users want more depth?)
- Performance impact analysis

---

**Section 4 Summary:**

| Feature | Version | Status | Priority | Complexity |
|---------|---------|--------|----------|------------|
| Category Heat Map | v1.0 | Required | P0 | Low |
| EV Differential | v1.1 | Should-Have | P1 | Low |
| Probability Halos | v2.0 | Could-Have | P2 | High |
| Decision Compass | v2.0 | Could-Have | P3 | High |
| Probability Wave | v2.0 | Could-Have | P4 | High |

---

## 5. Progressive Complexity Layers

### 5.1 Complexity Level System

The UI adapts statistical presentation across **3 manual complexity levels** (v1.0) expanding to 5 automated levels (v2.0).

**v1.0 Implementation: Manual Setting**

For v1.0, complexity is a **user-controlled dropdown** in settings:

```svelte
<select bind:value={statsProfile}>
  <option value="beginner">Beginner</option>
  <option value="intermediate">Intermediate</option>
  <option value="expert">Expert</option>
</select>
```

**Rationale:** Manual selection delivers 90% of value with 10% of complexity. Automated unlocking based on performance requires:
- Player accounts + persistent storage
- Analytics service + skill detection algorithm
- Backend infrastructure

These are unnecessary for v1.0 playability. Focus on core gameplay first.

**v1.0 Levels:**

| Level | User Selection | Stats Visible | Explanation Depth | When To Use |
|-------|----------------|---------------|-------------------|-------------|
| 1 | Beginner | Simple % | "Best choice" badge | First-time players, casual play |
| 2 | Intermediate | % + EV | "Because X" reasoning | Learning phase, exploring strategy |
| 3 | Expert | Full stats + tools | Mathematical details | Advanced analysis, teaching moments |

**v2.0 Enhancement: Automated Unlocking**

After v1.0 validation, add automatic level adjustment based on demonstrated skill:

| Level | Auto-Unlock Trigger | Stats Visible | Typical Games |
|-------|---------------------|---------------|---------------|
| 0 | First launch | Tutorial only | 1-2 |
| 1 | Complete tutorial | Simple % | 3-10 |
| 2 | >60% optimal over 10 games | % + EV | 11-30 |
| 3 | >75% optimal over 20 games | Decision trees + MC | 31-100 |
| 4 | >85% optimal over 50 games | Raw data + API | 100+ |

### 5.2 Layer 1: Beginner Mode (v1.0)

**Manual Selection: "Beginner"**

When enabled:
- Category Heat Map shows simple visual intensity only
- Best option has green badge: "★ Best Choice"
- No numerical probabilities or EV displayed
- Hover shows simple text: "Likely" | "Possible" | "Unlikely"

```svelte
<div class="category-row" class:best={category.isOptimal}>
  <span class="name">{category.displayName}</span>
  
  {#if statsProfile === 'beginner' && category.isOptimal}
    <span class="best-badge">★ Best Choice</span>
  {/if}
  
  {#if statsProfile === 'beginner' && category.probability}
    <span class="simple-probability">
      {category.probability > 0.5 ? 'Likely' : 
       category.probability > 0.2 ? 'Possible' : 
       'Unlikely'}
    </span>
  {/if}
</div>
```

**Goal:** Minimal cognitive load. Focus on gameplay, not numbers.

### 5.3 Layer 2: Intermediate Mode (v1.0)

**Manual Selection: "Intermediate"**

Adds numerical detail:
- Probability percentages visible
- EV numbers shown
- Top 3 options highlighted (gold/silver/bronze)
- "Why?" button for explanations

```svelte
<div class="category-row" class:tier={category.evRank}>
  <span class="name">{category.displayName}</span>
  
  {#if statsProfile !== 'beginner'}
    <span class="probability">{category.probability.toFixed(1)}%</span>
  {/if}
  
  {#if statsProfile === 'intermediate' || statsProfile === 'expert'}
    <span class="ev">EV: {category.expectedValue.toFixed(1)}</span>
  {/if}
  
  {#if category.evRank <= 3}
    <div class="rank-badge" class:gold={category.evRank === 1}
                             class:silver={category.evRank === 2}
                             class:bronze={category.evRank === 3}>
      {category.evRank === 1 ? '★' : category.evRank}
    </div>
  {/if}
  
  {#if statsProfile !== 'beginner'}
    <button class="explain-btn" onclick={() => showExplanation(category)}>
      Why?
    </button>
  {/if}
</div>
```

**Goal:** Introduce quantitative reasoning. Support "why is this better?" questions.

### 5.4 Layer 3: Expert Mode (v1.0)

**Manual Selection: "Expert"**

Full statistical access:
- All probabilities and EVs
- Decision comparison view
- Export probability tables (CSV)
- Monte Carlo controls (up to 100K iterations for v1.0)

```svelte
{#if statsProfile === 'expert'}
  <div class="expert-tools">
    <button onclick={() => showDecisionTree()}>
      📊 Compare All Options
    </button>
    
    <button onclick={() => exportProbabilities()}>
      📥 Export CSV
    </button>
    
    <details>
      <summary>Monte Carlo Simulation</summary>
      <input
        type="number"
        bind:value={monteCarloIterations}
        min="10000"
        max="100000"
        step="10000"
      />
      <button onclick={() => runSimulation()}>
        Run {monteCarloIterations.toLocaleString()} Simulations
      </button>
    </details>
  </div>
{/if}
```

**Goal:** Maximum transparency. Support advanced analysis and teaching.

### 5.5 Settings Interface (v1.0)

**Location:** Settings menu (gear icon in Context Layer)

```svelte
<div class="settings-panel">
  <h3>Statistical Display</h3>
  
  <label>
    <span>Stats Profile:</span>
    <select bind:value={statsProfile}>
      <option value="beginner">
        Beginner — Simple guidance
      </option>
      <option value="intermediate">
        Intermediate — Numbers + explanations
      </option>
      <option value="expert">
        Expert — Full analysis tools
      </option>
    </select>
  </label>
  
  <p class="help-text">
    {#if statsProfile === 'beginner'}
      Shows best moves without overwhelming numbers. Perfect for learning the game.
    {:else if statsProfile === 'intermediate'}
      Displays probabilities and expected values. Great for understanding strategy.
    {:else}
      Full statistical access including simulations and exports. For advanced players.
    {/if}
  </p>
  
  <label>
    <input type="checkbox" bind:checked={alwaysShowStats} />
    Always show statistics (even when Stats toggle is OFF)
  </label>
</div>
```

### 5.6 Migration Path to v2.0 Automation

**Data Collection (v1.0):**
Even with manual settings, collect telemetry:
- Decision quality (actual EV vs optimal EV)
- Time to decision
- Stats profile selection frequency

**v2.0 Activation:**
Once player accounts + backend exist:
1. Analyze historical performance
2. Suggest appropriate level: "Based on your play, try Intermediate mode?"
3. Option to enable "Auto-adjust complexity"
4. Smooth transitions between levels

**v2.0 Additional Levels:**
- **Level 0:** Tutorial-only (first 1-2 games)
- **Level 4:** Research mode (LaTeX proofs, source code, unlimited MC)

---

**Section 5 Summary:**

| Version | Implementation | Levels | Activation | Complexity |
|---------|----------------|--------|------------|------------|
| v1.0 | Manual dropdown | 3 | User choice | Low |
| v2.0 | Auto-adjust | 5 | Performance-based | Medium |

---

## 6. Component Specifications

### 6.1 Dice Tray Component

**Purpose:** Primary interaction surface for rolling and selecting dice

**States:**
- Idle (waiting for player action)
- Rolling (animation in progress)
- Selecting (player choosing which to keep)
- Locked (all dice held, awaiting score)

**Visual Specification:**

```svelte
<script lang="ts">
  import { Motion } from 'motion/svelte';
  
  let {
    dice = $bindable(),
    keptMask = $bindable([false, false, false, false, false]),
    onRoll,
    rollsRemaining
  } = $props();
  
  let rolling = $state(false);
</script>

<div class="dice-tray" data-rolling={rolling}>
  <!-- Dice grid -->
  <div class="dice-grid">
    {#each dice as value, i}
      <Motion
        animate={{
          rotateX: rolling ? [0, 360, 720] : 0,
          rotateY: rolling ? [0, 180, 360] : 0,
          scale: keptMask[i] ? 1.1 : 1
        }}
        transition={{ duration: 0.8, delay: i * 0.08 }}
      >
        <button
          class="die"
          class:held={keptMask[i]}
          onclick={() => !rolling && toggleKeep(i)}
          disabled={rolling}
        >
          <DieFace {value} />
          
          {#if keptMask[i]}
            <div class="hold-indicator">HELD</div>
          {/if}
        </button>
      </Motion>
    {/each}
  </div>
  
  <!-- Roll button -->
  <button
    class="roll-button"
    onclick={handleRoll}
    disabled={rolling || rollsRemaining === 0}
  >
    {rolling ? 'Rolling...' : `Roll (${rollsRemaining} left)`}
  </button>
  
  <!-- Quick actions -->
  <div class="quick-actions">
    <button onclick={keepAll}>Keep All</button>
    <button onclick={rerollAll}>Reroll All</button>
  </div>
</div>

<style>
  .dice-tray {
    background: linear-gradient(135deg, #1a5928, #2d7a3e);
    border: var(--border-thick);
    padding: var(--space-4);
    
    /* Casino felt texture */
    position: relative;
  }
  
  .dice-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: var(--space-3);
    margin-bottom: var(--space-3);
  }
  
  @media (max-width: 480px) {
    .dice-grid {
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-2);
    }
  }
  
  .die {
    aspect-ratio: 1;
    background: white;
    border: var(--border-medium);
    cursor: pointer;
    position: relative;
    
    display: grid;
    place-items: center;
    
    transition: all 150ms ease;
  }
  
  .die:hover:not(:disabled) {
    transform: translateY(-4px);
    border-width: 3px;
  }
  
  .die:active:not(:disabled) {
    transform: translateY(-2px);
  }
  
  .die.held {
    border-color: var(--color-accent);
    border-width: 4px;
    
    /* Neo-Brutalist: solid color, no gradients or shadows */
    background: var(--color-accent);
  }
  
  .hold-indicator {
    position: absolute;
    top: 4px;
    left: 4px;
    right: 4px;
    
    font-size: 10px;
    font-weight: 700;
    text-align: center;
    color: var(--color-accent-dark);
  }
  
  .roll-button {
    width: 100%;
    padding: var(--space-3);
    
    background: var(--color-accent);
    border: var(--border-thick);
    
    font-size: 18px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .roll-button:disabled {
    background: var(--color-disabled);
    cursor: not-allowed;
  }
  
  .quick-actions {
    display: flex;
    gap: var(--space-2);
    margin-top: var(--space-2);
  }
  
  .quick-actions button {
    flex: 1;
    padding: var(--space-1);
    
    background: transparent;
    border: var(--border-thin);
    color: white;
    
    font-size: 12px;
    text-transform: uppercase;
  }
</style>
```

**Interaction Behaviors:**
- **Tap die:** Toggle keep/release
- **Double-tap die:** Keep and auto-roll
- **Long-press tray:** Show probability overlay
- **Swipe die:** Quick keep (mobile gesture)

### 6.2 Scorecard Component

**Purpose:** Display all 13 categories with scoring state and recommendations

**Visual Specification:**

```svelte
<script lang="ts">
  let {
    scorecard,
    availableCategories,
    recommendations,
    statsMode,
    onScore
  } = $props();
  
  let hoveredCategory = $state<string | null>(null);
</script>

<div class="scorecard">
  <!-- Upper Section -->
  <section class="section upper">
    <h3 class="section-header">Upper Section</h3>
    
    {#each ['ones', 'twos', 'threes', 'fours', 'fives', 'sixes'] as cat}
      <CategoryRow
        category={cat}
        score={scorecard[cat]}
        available={availableCategories.has(cat)}
        recommendation={recommendations[cat]}
        {statsMode}
        onHover={() => hoveredCategory = cat}
        onScore={() => onScore(cat)}
      />
    {/each}
    
    <!-- Upper section totals -->
    <div class="total-row">
      <span>Upper Total</span>
      <span class="score-value">{scorecard.upperTotal}</span>
    </div>
    
    <div class="bonus-row" class:achieved={scorecard.upperBonus}>
      <span>Bonus (63+ points)</span>
      <span class="score-value">{scorecard.upperBonus ?? '—'}</span>
    </div>
  </section>
  
  <!-- Lower Section -->
  <section class="section lower">
    <h3 class="section-header">Lower Section</h3>
    
    {#each ['three_of_kind', 'four_of_kind', 'full_house', 
            'small_straight', 'large_straight', 'dicee', 'chance'] as cat}
      <CategoryRow
        category={cat}
        score={scorecard[cat]}
        available={availableCategories.has(cat)}
        recommendation={recommendations[cat]}
        {statsMode}
        onHover={() => hoveredCategory = cat}
        onScore={() => onScore(cat)}
      />
    {/each}
    
    <!-- Lower section total -->
    <div class="total-row">
      <span>Lower Total</span>
      <span class="score-value">{scorecard.lowerTotal}</span>
    </div>
  </section>
  
  <!-- Grand Total -->
  <div class="grand-total">
    <span>Grand Total</span>
    <span class="score-value">{scorecard.grandTotal}</span>
  </div>
</div>

<style>
  .scorecard {
    background: var(--color-surface);
    border: var(--border-medium);
  }
  
  .section {
    border-bottom: var(--border-thick);
    padding: var(--space-3);
  }
  
  .section-header {
    font-size: 18px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: var(--space-2);
    padding-bottom: var(--space-2);
    border-bottom: var(--border-thin);
  }
  
  .total-row {
    display: flex;
    justify-content: space-between;
    padding: var(--space-2);
    margin-top: var(--space-2);
    border-top: var(--border-thin);
    font-weight: 600;
  }
  
  .bonus-row {
    display: flex;
    justify-content: space-between;
    padding: var(--space-2);
    border-top: var(--border-thin);
    color: var(--color-disabled);
  }
  
  .bonus-row.achieved {
    color: var(--color-success);
    font-weight: 700;
  }
  
  .grand-total {
    display: flex;
    justify-content: space-between;
    padding: var(--space-3);
    
    background: var(--color-accent);
    border-top: var(--border-heavy);
    
    font-size: 20px;
    font-weight: 700;
    text-transform: uppercase;
  }
  
  .score-value {
    font-family: var(--font-mono);
    font-variant-numeric: tabular-nums;
  }
</style>
```

### 6.3 Category Row Component

**Purpose:** Individual category with score, probability, and interaction

```svelte
<script lang="ts">
  let {
    category,
    score,
    available,
    recommendation,
    statsMode,
    onHover,
    onScore
  } = $props();
  
  const displayNames = {
    ones: 'Ones',
    twos: 'Twos',
    // ... etc
    full_house: 'Full House',
    dicee: 'Dicee'
  };
  
  const icons = {
    ones: '⚀',
    twos: '⚁',
    // ... etc
    full_house: '🏠',
    dicee: '🎲'
  };
</script>

<button
  class="category-row"
  class:available
  class:scored={score !== undefined}
  class:optimal={recommendation?.isOptimal}
  class:hover={hovering}
  onmouseenter={onHover}
  onmouseleave={() => hovering = false}
  onclick={() => available && onScore()}
  disabled={!available}
>
  <!-- Category icon & name -->
  <div class="category-info">
    <span class="icon">{icons[category]}</span>
    <span class="name">{displayNames[category]}</span>
  </div>
  
  <!-- Score or probability -->
  <div class="category-value">
    {#if score !== undefined}
      <span class="score">{score}</span>
      <span class="scored-indicator">✓</span>
    {:else if statsMode && recommendation}
      <span class="probability">
        {recommendation.probability.toFixed(1)}%
      </span>
      {#if recommendation.expectedValue}
        <span class="ev">EV: {recommendation.expectedValue.toFixed(1)}</span>
      {/if}
    {:else}
      <span class="empty">—</span>
    {/if}
  </div>
  
  <!-- Optimal indicator -->
  {#if available && recommendation?.isOptimal}
    <div class="optimal-badge">★</div>
  {/if}
  
  <!-- Heat bar background -->
  {#if available && statsMode && recommendation}
    <div
      class="heat-bar"
      style:width="{recommendation.evPercentage}%"
    />
  {/if}
</button>

<style>
  .category-row {
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
    
    padding: var(--space-2);
    border: none;
    border-bottom: var(--border-thin);
    background: transparent;
    
    text-align: left;
    cursor: pointer;
    
    transition: all 150ms ease;
  }
  
  .category-row:hover:not(:disabled) {
    background: rgba(255, 215, 0, 0.1);
    border-left: 4px solid var(--color-accent);
    padding-left: calc(var(--space-2) - 4px);
  }
  
  .category-row.optimal {
    border-left: 3px solid var(--color-success);
    padding-left: calc(var(--space-2) - 3px);
  }
  
  .category-row.scored {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .category-row:disabled {
    cursor: not-allowed;
  }
  
  .category-info {
    display: flex;
    gap: var(--space-2);
    align-items: center;
  }
  
  .icon {
    font-size: 20px;
  }
  
  .name {
    font-weight: 500;
  }
  
  .category-value {
    display: flex;
    gap: var(--space-2);
    align-items: center;
    font-family: var(--font-mono);
  }
  
  .score {
    font-weight: 700;
    font-size: 18px;
  }
  
  .probability {
    color: var(--color-text);
    font-weight: 600;
  }
  
  .ev {
    font-size: 12px;
    color: var(--color-text);
    opacity: 0.7;
  }
  
  .optimal-badge {
    position: absolute;
    right: var(--space-2);
    
    width: 24px;
    height: 24px;
    
    display: grid;
    place-items: center;
    
    background: var(--color-accent);
    border: var(--border-medium);
    
    font-size: 14px;
  }
  
  .heat-bar {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    
    background: var(--color-accent);
    opacity: 0.2;
    
    pointer-events: none;
    transition: width 300ms ease;
  }
  
  .category-row:hover .heat-bar {
    opacity: 0.3;
  }
</style>
```

### 6.4 Stats Toggle Component

**Purpose:** Global switch for statistical overlay

```svelte
<script lang="ts">
  let { enabled = $bindable(false) } = $props();
</script>

<button
  class="stats-toggle"
  class:enabled
  onclick={() => enabled = !enabled}
>
  <div class="toggle-track">
    <div class="toggle-thumb" />
  </div>
  
  <span class="label">
    Stats: {enabled ? 'ON' : 'OFF'}
  </span>
</button>

<style>
  .stats-toggle {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    
    padding: var(--space-2);
    border: var(--border-medium);
    background: var(--color-surface);
    
    cursor: pointer;
    transition: all 150ms ease;
  }
  
  .stats-toggle:hover {
    border-color: var(--color-accent);
  }
  
  .toggle-track {
    width: 48px;
    height: 24px;
    
    position: relative;
    
    background: var(--color-disabled);
    border: var(--border-medium);
    
    transition: background 200ms ease;
  }
  
  .stats-toggle.enabled .toggle-track {
    background: var(--color-accent);
  }
  
  .toggle-thumb {
    position: absolute;
    top: 2px;
    left: 2px;
    
    width: 16px;
    height: 16px;
    
    background: white;
    border: var(--border-thin);
    
    transition: transform 200ms ease;
  }
  
  .stats-toggle.enabled .toggle-thumb {
    transform: translateX(24px);
  }
  
  .label {
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
</style>
```

---

## 7. Interaction Patterns & Gestures

### 7.1 Dice Interaction

**Mouse/Trackpad:**
- **Click:** Toggle keep/release
- **Double-click:** Keep and auto-suggest categories
- **Right-click:** Show detailed probability breakdown
- **Hover:** Display probability halo

**Touch:**
- **Tap:** Toggle keep/release
- **Double-tap:** Keep and highlight recommended categories
- **Long-press (500ms):** Show detailed statistics modal
- **Swipe up:** Instant keep
- **Swipe down:** Instant release

### 7.2 Scorecard Interaction

**Mouse/Trackpad:**
- **Hover:** Show potential score and EV
- **Click:** Score category (if available)
- **Right-click:** Explain recommendation
- **Shift+Click:** Pin comparison view

**Touch:**
- **Tap:** Score category
- **Long-press:** Show explanation modal
- **Swipe left:** Show alternatives
- **Swipe right:** Compare with optimal

### 7.3 Keyboard Shortcuts

**Navigation:**
- `Tab` / `Shift+Tab`: Navigate elements
- `Space`: Roll dice / confirm action
- `Enter`: Score selected category
- `Esc`: Cancel / close modals

**Dice Control:**
- `1-5`: Toggle keep on die 1-5
- `Shift+1-5`: Keep only die 1-5, release others
- `A`: Keep all dice
- `R`: Release all dice

**Stats:**
- `S`: Toggle stats mode
- `H`: Show/hide statistical HUD
- `E`: Show EV comparison chart
- `?`: Show help overlay

### 7.4 Gesture Feedback

**Visual:**
- **Ripple effect** on tap/click
- **Lift animation** on die selection
- **Border pulse** on optimal category
- **Flash** on successful score

**Haptic (Mobile):**
- **Light:** Dice tap toggle
- **Medium:** Roll button press
- **Heavy:** Successful score
- **Success pattern:** Optimal decision
- **Warning pattern:** Suboptimal choice

---

## 8. Responsive Adaptation Strategy

### 8.1 Breakpoint System

```css
/* Mobile portrait (baseline) */
@media (min-width: 320px) {
  :root {
    --canvas-width: 100vw;
    --zone-action: 40vh;
    --zone-decision: 50vh;
    --zone-context: 10vh;
  }
}

/* Mobile landscape */
@media (min-width: 568px) and (orientation: landscape) {
  :root {
    --canvas-width: 100vw;
    --layout: two-column;
  }
}

/* Tablet portrait */
@media (min-width: 768px) {
  :root {
    --canvas-width: 768px;
    --zone-action: 35vh;
    --zone-decision: 55vh;
  }
}

/* Desktop small */
@media (min-width: 1024px) {
  :root {
    --canvas-width: 1024px;
    --layout: three-column;
    --show-analytics: true;
  }
}

/* Desktop large */
@media (min-width: 1440px) {
  :root {
    --canvas-width: 1440px;
    --scale: 1.1;
  }
}

/* Ultra-wide */
@media (min-width: 1920px) {
  :root {
    --canvas-width: 1600px;
    --show-extended-stats: true;
  }
}
```

### 8.2 Container Queries

Modern CSS container queries for component-level responsiveness:

```css
.dice-tray {
  container-type: inline-size;
  container-name: dice-tray;
}

/* Adaptive dice size */
@container dice-tray (max-width: 400px) {
  .die {
    width: 50px;
    height: 50px;
  }
}

@container dice-tray (min-width: 600px) {
  .die {
    width: 80px;
    height: 80px;
  }
}

/* Scorecard adaptive layout */
.scorecard {
  container-type: inline-size;
}

@container (min-width: 600px) {
  .category-row {
    grid-template-columns: 2fr 1fr 1fr;
  }
}
```

### 8.3 Touch vs. Mouse Optimization

**Detection:**

```typescript
const hasTouch = 'ontouchstart' in window;
const hasMouse = window.matchMedia('(pointer: fine)').matches;

if (hasTouch && !hasMouse) {
  // Touch-only device (mobile)
  document.body.classList.add('touch-device');
} else if (hasMouse) {
  // Mouse device (desktop)
  document.body.classList.add('mouse-device');
} else {
  // Hybrid (laptop with touchscreen)
  document.body.classList.add('hybrid-device');
}
```

**Adaptive Interaction:**

```css
/* Larger touch targets on touch devices */
.touch-device .die {
  min-width: 64px;
  min-height: 64px;
}

.touch-device .category-row {
  min-height: 56px;
}

/* Hover effects only on mouse devices */
.mouse-device .die:hover {
  transform: translateY(-4px);
}

.touch-device .die:active {
  transform: scale(0.95);
}
```

---

## 9. Animation & Motion Design

### 9.1 Animation Philosophy

**Purposeful Motion:**
- Every animation communicates state change or provides feedback
- No gratuitous effects
- Performance-first (60fps minimum)

**Timing Principles:**
- **Instant:** <100ms (imperceptible)
- **Quick:** 150-200ms (responsive)
- **Medium:** 300-400ms (noticeable transition)
- **Slow:** 500-800ms (dramatic events)

### 9.2 Dice Roll Animation

**Three-Stage Animation:**

```typescript
async function animateDiceRoll(diceResults: number[]) {
  // Stage 1: Anticipation (100ms)
  await animate('.dice-tray', {
    scale: [1, 0.98],
    duration: 100
  });
  
  // Stage 2: Roll (800ms)
  const rollAnimations = diceResults.map((result, i) => {
    return animate(`.die-${i}`, {
      rotateX: [0, 720],
      rotateY: [0, 360],
      duration: 800,
      delay: i * 80,
      easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
    });
  });
  
  await Promise.all(rollAnimations);
  
  // Stage 3: Settle (200ms)
  await animate('.dice-tray', {
    scale: [0.98, 1],
    duration: 200,
    easing: 'ease-out'
  });
}
```

### 9.3 Score Animation

**Number Count-Up:**

```svelte
<script>
  import { spring } from 'svelte/motion';
  
  let { value } = $props();
  let displayed = spring(0, { stiffness: 0.1, damping: 0.3 });
  
  $effect(() => {
    displayed.set(value);
  });
</script>

<span class="score-value">
  {Math.floor($displayed)}
</span>
```

### 9.4 Category Selection Feedback

```css
@keyframes score-pulse {
  0% {
    transform: scale(1);
    background: var(--color-surface);
  }
  50% {
    transform: scale(1.05);
    background: var(--color-accent);
  }
  100% {
    transform: scale(1);
    background: var(--color-surface);
  }
}

.category-row.just-scored {
  animation: score-pulse 500ms ease-out;
}
```

### 9.5 Optimal Decision Celebration

**Confetti Burst (Canvas-based):**

```typescript
class OptimalDecisionEffect {
  private canvas: HTMLCanvasElement;
  private particles: Particle[] = [];
  
  trigger(x: number, y: number) {
    // Create 30 particles
    for (let i = 0; i < 30; i++) {
      this.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        color: ['#FFD700', '#10B981', '#FFFFFF'][Math.floor(Math.random() * 3)],
        life: 1.0
      });
    }
    
    this.animate();
  }
  
  private animate() {
    // Physics simulation with gravity
    this.particles = this.particles.filter(p => p.life > 0);
    
    this.particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.5; // Gravity
      p.life -= 0.02;
    });
    
    this.render();
    
    if (this.particles.length > 0) {
      requestAnimationFrame(() => this.animate());
    }
  }
}
```

---

## 10. Accessibility & Inclusive Design

### 10.1 WCAG 2.1 AA Compliance

**Color Contrast:**
- Text: 4.5:1 minimum
- Large text (≥18px): 3:1 minimum
- UI components: 3:1 minimum

**Validation:**

```typescript
function validateContrast(fg: string, bg: string, size: number): boolean {
  const ratio = calculateContrastRatio(fg, bg);
  const minRatio = size >= 18 ? 3 : 4.5;
  return ratio >= minRatio;
}

// Example checks
assert(validateContrast('#0A0A0A', '#FAFAFA', 16)); // ✓ 18.5:1
assert(validateContrast('#FFD700', '#FFFFFF', 24)); // ✓ 1.3:1 (large text)
```

### 10.2 Keyboard Navigation

**Focus Management:**

```css
*:focus-visible {
  outline: 3px solid var(--color-accent);
  outline-offset: 2px;
}

.die:focus-visible {
  outline: 4px solid var(--color-accent);
  outline-offset: 4px;
}
```

**Focus Trapping in Modals:**

```typescript
function trapFocus(container: HTMLElement) {
  const focusableElements = container.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  
  const firstElement = focusableElements[0] as HTMLElement;
  const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
  
  container.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      if (e.shiftKey && document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  });
}
```

### 10.3 Screen Reader Support

**ARIA Labels:**

```svelte
<button
  class="die"
  aria-label="Die showing {value}, {held ? 'held' : 'not held'}"
  aria-pressed={held}
  onclick={toggleHold}
>
  <DieFace {value} />
</button>

<div class="category-row" role="button" tabindex="0">
  <span id="cat-{id}">{categoryName}</span>
  <span aria-labelledby="cat-{id}">
    {#if statsMode}
      Probability: {probability}%, Expected value: {ev} points
    {/if}
  </span>
</div>
```

**Live Regions:**

```svelte
<div aria-live="polite" aria-atomic="true" class="sr-only">
  {#if rollResult}
    Rolled: {rollResult.join(', ')}. 
    {rollsRemaining} {rollsRemaining === 1 ? 'roll' : 'rolls'} remaining.
  {/if}
</div>

<div aria-live="assertive" aria-atomic="true" class="sr-only">
  {#if scoreResult}
    Scored {scoreResult.points} points in {scoreResult.category}.
    {scoreResult.isOptimal ? 'Optimal decision!' : ''}
  {/if}
</div>
```

### 10.4 Reduced Motion

```css
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
  
  .die {
    /* Instant state changes, no rotation */
  }
  
  .probability-halo {
    /* No animation, just fade */
    transition: opacity 100ms ease;
  }
}
```

### 10.5 Text Scaling

**Support up to 200% text zoom:**

```css
/* Use rem for all font sizes */
body {
  font-size: 16px; /* Base */
}

h1 {
  font-size: 2.375rem; /* 38px at 100%, 76px at 200% */
}

.category-row {
  /* Ensure container grows with text */
  min-height: 3.5rem; /* 56px at 100%, 112px at 200% */
}

/* Prevent text overlap */
.category-info {
  flex: 1;
  min-width: 0; /* Allow text truncation */
}
```

---

## 11. Performance Budget

### 11.1 Loading Performance

**Metrics:**

| Metric | Target | Measurement |
|--------|--------|-------------|
| First Contentful Paint | <1.5s | Lighthouse |
| Largest Contentful Paint | <2.5s | Lighthouse |
| Time to Interactive | <3.5s | Lighthouse |
| Cumulative Layout Shift | <0.1 | Lighthouse |

**Bundle Size:**

| Asset | Size | Compression |
|-------|------|-------------|
| HTML | 15 KB | gzip |
| CSS | 25 KB | gzip |
| JavaScript | 150 KB | gzip + brotli |
| WASM Engine | 150 KB | gzip |
| **Total** | **340 KB** | First load |

### 11.2 Runtime Performance

**Frame Rate:**
- 60 FPS minimum during gameplay
- 30 FPS acceptable during heavy animations

**Animation Budget:**

| Action | Budget | Measurement |
|--------|--------|-------------|
| Dice roll | <800ms | Start to settle |
| Category hover | <50ms | Mouseover to feedback |
| Score update | <200ms | Click to UI update |
| Stats toggle | <100ms | Toggle to display |

**Memory:**

```typescript
// Monitoring
if ('memory' in performance) {
  const heap = (performance as any).memory;
  
  if (heap.usedJSHeapSize > 100 * 1024 * 1024) {
    console.warn('Memory usage high:', heap.usedJSHeapSize);
  }
}
```

### 11.3 Network Performance

**API Call Budget:**

| Action | Calls | Latency Target |
|--------|-------|----------------|
| Roll dice | 1 | <50ms |
| Score category | 2 | <100ms |
| Load game | 1 | <200ms |
| Stats update | 0 | (WASM, client-side) |

**Caching Strategy:**

```typescript
// Service Worker caching
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('dicee-v1').then((cache) => {
      return cache.addAll([
        '/',
        '/app.css',
        '/app.js',
        '/probability-engine.wasm'
      ]);
    })
  );
});
```

---

## 12. Implementation Roadmap

### Phase 1: Core Layout & Components (Week 1) — v1.0

**Deliverables:**
- ✅ Canvas architecture implemented (30/60/10 mobile split)
- ✅ Neo-brutalist design system in CSS (no gradients, no shadows)
- ✅ Dice tray component with basic animations
- ✅ Scorecard component (basic structure)
- ✅ Responsive layout (mobile + desktop)
- ✅ Manual stats profile dropdown (Beginner/Intermediate/Expert)

**Technologies:**
- Svelte 5 with Runes
- Tailwind CSS (custom config)
- Motion One for animations (simple only)

**Scope Discipline:**
- NO probability halos (deferred to v2.0)
- NO decision compass (deferred to v2.0)
- NO animated dice roll (simple state change only)
- Focus: functional layout, clean code

### Phase 2: Statistical HUD — MVP (Week 2) — v1.0

**Deliverables:**
- ✅ Category Heat Map implementation (PRIORITY 0)
  - Visual intensity bars
  - Optimal category badge
  - Probability percentages (when stats enabled)
  - EV values (intermediate+ only)
- ✅ Stats toggle control (ON/OFF)
- ✅ Manual stats profile system working
- ✅ Integration with RFC-001 Statistical Engine
- ✅ WASM probability engine connected

**What's NOT Included (Deferred):**
- ❌ EV Differential Display (v1.1)
- ❌ Decision Compass (v2.0)
- ❌ Probability Wave (v2.0)
- ❌ Probability Halos (v2.0)

**Integration:**
- Connect Category Heat Map to WASM calculations
- Display P(category) and EV(category) from engine
- Real-time updates on dice changes

### Phase 3: Interactions & Feedback (Week 3) — v1.0

**Deliverables:**
- ✅ Dice selection gestures (tap/click to toggle)
- ✅ Category selection interaction
- ✅ Keyboard shortcuts (basic set)
- ✅ Animation polish (dice rolls, score updates)
- ✅ Haptic feedback (mobile only)

**Simplified Scope:**
- Simple roll animation (no 3D rotation, just fade-in)
- Basic touch gestures (no complex swipes)
- Essential keyboard shortcuts only (Space, Enter, 1-5)

**Polish:**
- Micro-interactions tuned
- Smooth transitions
- Immediate feedback loops

### Phase 4: Accessibility & Testing (Week 4) — v1.0

**Deliverables:**
- ✅ WCAG 2.1 AA compliance
- ✅ Screen reader support (ARIA labels)
- ✅ Keyboard navigation complete
- ✅ Reduced motion support
- ✅ Cross-browser testing (Chrome, Safari, Firefox)

**Validation:**
- Lighthouse scores >90
- Axe accessibility audit passed
- Manual testing with keyboard-only navigation
- Touch device testing (iOS + Android)

### Phase 5: v1.0 Polish & Ship (Week 5)

**Deliverables:**
- ✅ Bug fixes from testing
- ✅ Performance optimization (meet budgets)
- ✅ Tutorial mode (simple 3-step walkthrough)
- ✅ Settings panel (stats profile selection)
- ✅ Documentation (user guide, keyboard shortcuts)

**Success Criteria:**
- ✅ Complete game playable end-to-end
- ✅ Category Heat Map shows clear "best move"
- ✅ All three stats profiles working correctly
- ✅ Mobile and desktop responsive
- ✅ Accessible to keyboard users
- ✅ Performance: <3s load, 60fps gameplay

**v1.0 Feature Set (Complete):**
- Core Dicee gameplay
- Category Heat Map with P() and EV
- Manual stats profile selection (3 levels)
- Basic tutorial
- Responsive layout
- Full accessibility

---

### Post-v1.0: v1.1 Enhancement (Week 6-7)

**Add:**
- EV Differential Display (floating indicator)
- Enhanced animations (3D dice rotation)
- Sound effects (optional)
- Post-game summary screen

**Validation:**
- User testing with v1.0
- Feedback on missing features
- Decision: pursue v1.1 features or jump to v2.0

### Post-v1.1: v2.0 Advanced Features (Month 2-3)

**Add (Prioritized by User Feedback):**
- Probability Halos (if users want more dice context)
- Decision Compass (if users want decision tree viz)
- Probability Wave (if alternative viz desired)
- Automated complexity unlocking system
- Player accounts + persistence
- Analytics dashboard

**Note:** v2.0 features depend entirely on v1.0 validation. Do not start v2.0 work until:
1. v1.0 is played by real users (family)
2. Feedback collected on "what's missing?"
3. Analytics show engagement patterns
4. Technical debt from v1.0 is resolved

---

### Critical Success Factors

**v1.0 Must:**
- Be playable and fun WITHOUT advanced HUD features
- Teach probability through Category Heat Map alone
- Work smoothly on both mobile and desktop
- Feel fast and responsive (<100ms interactions)
- Be accessible to all skill levels via manual profiles

**v1.0 Must NOT:**
- Attempt advanced visualizations
- Require backend infrastructure beyond basic API
- Include automated systems that need analytics
- Exceed 5-week timeline

**Acceptance Criteria:**
- [ ] Can you play a complete 13-turn game smoothly?
- [ ] Does the Heat Map clearly show the best move?
- [ ] Can you switch between Beginner/Intermediate/Expert modes?
- [ ] Does it work on your phone and laptop?
- [ ] Can someone navigate it with keyboard only?
- [ ] Is it fun to play?

If all YES → Ship v1.0  
If any NO → Fix before moving to v1.1

---

## 13. Design Validation Metrics

### 13.1 Usability Metrics

**Task Success Rates:**

| Task | Target | Measurement |
|------|--------|-------------|
| First roll completion | 100% | Within 30s of landing |
| First score selection | >95% | Without errors |
| Stats toggle discovery | >70% | Within first 3 games |
| Category hover interaction | >80% | Natural discovery |

### 13.2 Performance Metrics

**User-Perceived Speed:**

| Interaction | Target | Actual |
|-------------|--------|--------|
| Dice roll response | <100ms | TBD |
| Category selection | <50ms | TBD |
| Stats overlay appear | <150ms | TBD |
| Page load (mobile) | <3s | TBD |

### 13.3 Engagement Metrics

**Statistical Feature Usage:**

- Stats mode activation rate: >60% of players
- Hover interaction rate: >50% of decisions
- Advanced tools usage (after unlock): >30%
- Tutorial completion: >80%

### 13.4 Learning Effectiveness

**Decision Quality Improvement:**

| Metric | Baseline | After 10 Games | After 20 Games |
|--------|----------|----------------|----------------|
| Optimal decisions | 35% | 60% | 75% |
| EV awareness | Low | Medium | High |
| Stats confidence | Low | Medium | High |

---

## 14. Appendices

### Appendix A: Design System Tokens

```typescript
// Design tokens (exported as JSON/CSS/Figma)
export const designTokens = {
  colors: {
    background: '#FAFAFA',
    surface: '#FFFFFF',
    border: '#000000',
    text: '#0A0A0A',
    accent: '#FFD700',
    success: '#10B981',
    warning: '#F59E0B',
    danger: '#EF4444'
  },
  
  spacing: {
    1: '0.5rem',
    2: '1rem',
    3: '1.5rem',
    4: '2rem',
    5: '3rem',
    6: '4rem'
  },
  
  typography: {
    fontFamily: {
      sans: 'Inter Variable, SF Pro, system-ui',
      mono: 'JetBrains Mono, SF Mono, Courier New'
    },
    fontSize: {
      display: '48px',
      h1: '38px',
      h2: '30px',
      h3: '24px',
      body: '16px',
      small: '14px',
      tiny: '12px'
    },
    fontWeight: {
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    }
  },
  
  borders: {
    thin: '1px solid',
    medium: '2px solid',
    thick: '3px solid',
    heavy: '4px solid'
  },
  
  transitions: {
    fast: '150ms ease',
    medium: '300ms ease',
    slow: '500ms ease'
  }
};
```

### Appendix B: Component Library Structure

```
packages/ui/src/
├── components/
│   ├── dice/
│   │   ├── DiceTray.svelte
│   │   ├── Die.svelte
│   │   ├── DieFace.svelte
│   │   └── ProbabilityHalo.svelte
│   ├── scorecard/
│   │   ├── Scorecard.svelte
│   │   ├── CategoryRow.svelte
│   │   ├── SectionHeader.svelte
│   │   └── TotalRow.svelte
│   ├── hud/
│   │   ├── EVDifferential.svelte
│   │   ├── DecisionCompass.svelte
│   │   ├── ProbabilityWave.svelte
│   │   └── StatsToggle.svelte
│   └── shared/
│       ├── Button.svelte
│       ├── Card.svelte
│       ├── Modal.svelte
│       └── Tooltip.svelte
├── layouts/
│   ├── MobileLayout.svelte
│   ├── TabletLayout.svelte
│   └── DesktopLayout.svelte
├── styles/
│   ├── global.css
│   ├── tokens.css
│   └── animations.css
└── utils/
    ├── motion.ts
    ├── gestures.ts
    └── accessibility.ts
```

### Appendix C: Figma Design File Structure

```
Dicee Design System
├── 📘 Cover & Overview
├── 🎨 Design Tokens
│   ├── Colors
│   ├── Typography
│   ├── Spacing
│   └── Borders
├── 🧩 Components
│   ├── Atoms (Dice, Buttons, Icons)
│   ├── Molecules (Category Row, Dice Tray)
│   └── Organisms (Scorecard, HUD)
├── 📱 Mobile Screens
│   ├── Game - Initial State
│   ├── Game - Rolling
│   ├── Game - Stats ON
│   └── Game - Completed
├── 💻 Desktop Screens
│   ├── Game - Three Column
│   └── Game - Analytics Panel
└── 🎭 States & Variations
    ├── Beginner Mode
    ├── Intermediate Mode
    └── Advanced Mode
```

### Appendix D: Animation Specifications

**Dice Roll Timing Function:**

```css
/* Custom easing for natural dice physics */
@keyframes dice-roll {
  0% {
    transform: rotateX(0deg) rotateY(0deg);
  }
  30% {
    transform: rotateX(180deg) rotateY(90deg);
  }
  60% {
    transform: rotateX(360deg) rotateY(270deg);
  }
  100% {
    transform: rotateX(720deg) rotateY(360deg);
  }
}

.die.rolling {
  animation: dice-roll 800ms cubic-bezier(0.34, 1.56, 0.64, 1);
}
```

**Probability Halo Pulse:**

```css
@keyframes halo-pulse {
  0%, 100% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.05);
  }
}

.probability-halo.active {
  animation: halo-pulse 2s ease-in-out infinite;
}
```

---

**Document Status:** ✅ RFC Ready for Review  
**Next Steps:**
1. Design review with team
2. Prototype key interactions in Figma
3. Implement Phase 1 (Core Layout)
4. User testing with target audience (middle schoolers + parents)

**Related Documents:**
- RFC-001: Statistical Engine Architecture ✅
- RFC-003: Data Contracts & Event Schema (Next)
- RFC-004: Game Loop & Mechanics (Next)

========================================
FILE: rfc-003-data-contracts.md
========================================

# RFC-003: Data Contracts & Event Schema
**Project:** Dicee — Educational Probability Platform  
**RFC Status:** Draft → Review  
**Version:** 1.0  
**Date:** October 25, 2025  
**Authors:** Engineering Team  
**Reviewers:** TBD

---

## Document Status & Versioning

| Version | Date | Changes | Status |
|---------|------|---------|--------|
| 1.0 | 2025-10-25 | Initial data contracts specification | Superseded |
| 1.1 | 2025-10-25 | Post-review revision: event categorization, slimmed events, integrity rules, invariants | Current |

**Review Summary:** Strong foundation with critical improvements applied. Split events into domain/analysis/telemetry streams, reduced event payload sizes, added game integrity rules and safety invariants, strengthened audit trail.

**Related RFCs:**
- RFC-001: Statistical Engine Architecture ✅
- RFC-002: UI/UX Canvas Design ✅
- RFC-004: Game Loop & Mechanics (Next)
- RFC-005: Adaptive Learning Model (Next)
- RFC-006: Event Model & Telemetry (Depends on this)
- RFC-007: API Integration Contract (Depends on this)

**Dependencies:**
- This RFC defines contracts used by all other RFCs
- RFC-006 will implement persistence for these schemas
- RFC-007 will implement transport for these contracts

---

## Abstract

This RFC specifies the **canonical data contracts** for the Dicee platform. It defines all event schemas, API request/response formats, data validation rules, and schema versioning strategies. These contracts form the **interface boundary** between all services (WASM Engine, Decision Analyzer, Learning Tracker, Frontend) and ensure type safety, backward compatibility, and data integrity across the system.

**Key Innovation:** Domain-driven event sourcing with strict schema versioning, enabling complete game reconstruction and time-travel debugging while maintaining forward/backward compatibility.

---

## Table of Contents

1. [Design Principles](#1-design-principles)
2. [Schema Versioning Strategy](#2-schema-versioning-strategy)
3. [Event Categorization & Streams](#3-event-categorization--streams)
4. [Core Type Definitions](#4-core-type-definitions)
5. [Event Schema Specification](#5-event-schema-specification)
6. [API Request/Response Contracts](#6-api-requestresponse-contracts)
7. [WebSocket Protocol](#7-websocket-protocol)
8. [Data Validation Rules](#8-data-validation-rules)
9. [Game Integrity Rules](#9-game-integrity-rules)
10. [Safety Invariants](#10-safety-invariants)
11. [Error Schema](#11-error-schema)
12. [Schema Evolution Guidelines](#12-schema-evolution-guidelines)
13. [Implementation Checklist](#13-implementation-checklist)
14. [Appendices](#14-appendices)

---

## 1. Design Principles

### 1.1 Core Principles

**1. Events Are Immutable**
- Once written, events cannot be modified or deleted
- All state changes are captured as new events
- Game state is derived from event replay

**2. Schemas Are Versioned**
- Every schema has a version field (semver)
- Breaking changes increment major version
- All services must handle multiple schema versions
- Backward compatibility for 2 major versions

**3. Strong Typing**
- All contracts have TypeScript definitions
- Rust types for WASM engine
- Python Pydantic models for services
- JSON Schema for validation

**4. Explicit Over Implicit**
- All fields are required unless marked optional
- No implicit type coercion
- Validation errors are detailed and actionable

**5. Traceable**
- Every event has `traceId` for distributed tracing
- `causalChain` links cause-and-effect
- Timestamps in ISO 8601 format (UTC)

### 1.2 Naming Conventions

**Events:** PascalCase + "Event" suffix
- ✅ `RollEvent`, `ScoreDecisionEvent`
- ❌ `roll_event`, `score_evt`

**Fields:** camelCase
- ✅ `diceResult`, `timeToDecision`
- ❌ `dice_result`, `TimeToDecision`

**Enums:** lowercase with underscores
- ✅ `"three_of_kind"`, `"large_straight"`
- ❌ `"ThreeOfKind"`, `"largeStraight"`

**Timestamps:** Unix epoch milliseconds (number) OR ISO 8601 strings
- ✅ `1698765432000` or `"2024-10-31T12:30:32.000Z"`
- ❌ `"2024-10-31"`, `"12:30 PM"`

---

## 2. Schema Versioning Strategy

### 2.1 Version Format

All schemas follow **semantic versioning**:

```
MAJOR.MINOR.PATCH

MAJOR: Breaking changes (remove field, change type)
MINOR: Additive changes (new optional field)
PATCH: Documentation or validation refinements
```

### 2.2 Version Compatibility Matrix

| Current Version | Can Read | Can Write |
|----------------|----------|-----------|
| 1.0.0 | 1.x.x | 1.0.x |
| 1.5.0 | 1.x.x | 1.5.x |
| 2.0.0 | 1.x.x, 2.x.x | 2.0.x |
| 2.1.0 | 1.x.x, 2.x.x | 2.1.x |

**Rules:**
- Services must read all minor versions within their major version
- Services must read the previous major version (1 major back)
- Services write only their exact version

### 2.3 Schema Migration Process

**Adding a field (MINOR version bump):**

```typescript
// v1.0.0
interface RollEvent {
  eventType: "roll";
  diceResult: number[];
}

// v1.1.0 - Add optional field
interface RollEvent {
  eventType: "roll";
  eventVersion: "1.1.0";
  diceResult: number[];
  keptMask?: boolean[];  // NEW - optional for backward compat
}
```

**Breaking change (MAJOR version bump):**

```typescript
// v1.x.x
interface RollEvent {
  diceResult: number[];  // Array of 5 numbers
}

// v2.0.0 - Change field type
interface RollEvent {
  eventVersion: "2.0.0";
  diceResult: [number, number, number, number, number];  // Tuple
}
```

---

## 3. Event Categorization & Streams

### 3.1 Three-Stream Architecture

Events are categorized into three distinct streams to optimize storage, querying, and replay performance:

| Stream Type | Purpose | Retention | Examples |
|-------------|---------|-----------|----------|
| **Domain Events** | Game state reconstruction | Permanent | `GameCreatedEvent`, `RollEvent`, `ScoreDecisionEvent` |
| **Analysis Events** | Statistical computations | 90 days | `AnalysisComputedEvent`, `RecommendationEvent` |
| **Telemetry Events** | Learning metrics & UX | 30 days | `HoverEvent`, `PredictionEvent`, `HintRequestedEvent` |

**Why Three Streams?**

1. **Storage Efficiency** — Domain events are small and permanent; heavy analysis results can be pruned
2. **Replay Performance** — Rebuilding game state doesn't require loading millions of hover events
3. **Query Optimization** — Different access patterns (real-time vs. batch analytics)
4. **Cost Control** — Telemetry can use cheaper storage; domain events use premium durability

### 3.2 Stream Routing

Every event has a `streamType` field that determines routing:

```typescript
type StreamType = 
  | "domain"      // Required for game state reconstruction
  | "analysis"    // Computational results (can be recomputed)
  | "telemetry";  // UX metrics for learning analytics

interface BaseGameEvent {
  // ... other fields
  streamType: StreamType;
}
```

**Routing Rules:**

```typescript
const STREAM_ROUTING = {
  domain: {
    storage: "postgresql",
    retention: "permanent",
    replication: "sync",
    backup: "hourly"
  },
  analysis: {
    storage: "postgresql",
    retention: "90_days",
    replication: "async",
    backup: "daily"
  },
  telemetry: {
    storage: "timescaledb",  // Or ClickHouse for analytics
    retention: "30_days",
    replication: "async",
    backup: "weekly"
  }
};
```

### 3.3 Event Classification Matrix

| Event Type | Stream | Rationale |
|------------|--------|-----------|
| `GameCreatedEvent` | domain | Required for reconstruction |
| `GameStartedEvent` | domain | Required for reconstruction |
| `RollEvent` | domain | Core game action |
| `RerollEvent` | domain | Core game action |
| `ScoreDecisionEvent` | domain | Core game action |
| `GameCompletedEvent` | domain | Required for reconstruction |
| `AnalysisComputedEvent` | analysis | Can be recomputed from domain events |
| `RecommendationEvent` | analysis | Can be recomputed from domain events |
| `HoverEvent` | telemetry | Learning metric only |
| `PredictionEvent` | telemetry | Learning metric only |
| `HintRequestedEvent` | telemetry | Learning metric only |
| `ErrorEvent` | domain | Required for audit trail |

### 3.4 Event Linking

Analysis and telemetry events link back to domain events via `causalChain`:

```typescript
// Domain event
const rollEvent: RollEvent = {
  id: "evt_001",
  streamType: "domain",
  // ...
};

// Analysis event (linked)
const analysisEvent: AnalysisComputedEvent = {
  id: "evt_002",
  streamType: "analysis",
  causalChain: ["evt_001"],  // Links to roll
  // ...
};

// Telemetry event (linked)
const hoverEvent: HoverEvent = {
  id: "evt_003",
  streamType: "telemetry",
  causalChain: ["evt_001"],  // Links to roll
  // ...
};
```

---

## 4. Core Type Definitions

### 4.1 Base Types

```typescript
// Primitive Types
type UUID = string;  // UUIDv4 format
type Timestamp = number;  // Unix epoch milliseconds
type ISODateTime = string;  // ISO 8601 format

// Dice
type DieValue = 1 | 2 | 3 | 4 | 5 | 6;
type DiceArray = [DieValue, DieValue, DieValue, DieValue, DieValue];
type KeptMask = [boolean, boolean, boolean, boolean, boolean];

// Roll Types
type RollType = "initial" | "reroll";

// Event Source
type EventSource = "client" | "server" | "engine" | "system";

// Dicee Categories
type DiceeCategory =
  // Upper section
  | "ones"
  | "twos"
  | "threes"
  | "fours"
  | "fives"
  | "sixes"
  // Lower section
  | "three_of_kind"
  | "four_of_kind"
  | "full_house"
  | "small_straight"
  | "large_straight"
  | "dicee"
  | "chance";

// Decision Quality
type DecisionQuality =
  | "optimal"      // Best EV choice
  | "excellent"    // Within 5% of optimal
  | "good"         // Within 10% of optimal
  | "acceptable"   // Within 20% of optimal
  | "suboptimal"   // Within 50% of optimal
  | "poor";        // >50% below optimal

// Player Skill Level
type SkillLevel =
  | "beginner"     // Learning probability basics
  | "intermediate" // Understanding EV
  | "advanced"     // Mastering strategy
  | "expert";      // Optimal play

// Game Status
type GameStatus =
  | "waiting"      // Lobby, not started
  | "active"       // In progress
  | "completed"    // Finished normally
  | "abandoned";   // Player left

// Turn Phase
type TurnPhase =
  | "initial_roll" // Turn 1, roll 1
  | "mid_turn"     // Rolls 2-3
  | "scoring";     // Choosing category
```

### 4.2 Scorecard Model

```typescript
interface Scorecard {
  // Upper Section
  ones?: number;
  twos?: number;
  threes?: number;
  fours?: number;
  fives?: number;
  sixes?: number;
  upperSubtotal: number;     // Sum of upper section
  upperBonus: number;        // 35 if upperSubtotal >= 63, else 0
  upperTotal: number;        // upperSubtotal + upperBonus
  
  // Lower Section
  threeOfKind?: number;
  fourOfKind?: number;
  fullHouse?: number;        // 25 or 0
  smallStraight?: number;    // 30 or 0
  largeStraight?: number;    // 40 or 0
  dicee?: number;          // 50 or 0
  chance?: number;
  diceeBonus: number;      // 100 per extra Dicee
  lowerTotal: number;        // Sum of lower section
  
  // Grand Total
  grandTotal: number;        // upperTotal + lowerTotal
  
  // Metadata
  categoriesRemaining: DiceeCategory[];
  turnsCompleted: number;    // 0-13
}
```

### 4.3 Probability Vector

```typescript
interface ProbabilityVector {
  // Per-category probabilities and values
  categories: Record<DiceeCategory, CategoryStatistics>;
  
  // Optimal recommendation
  optimalCategory: DiceeCategory;
  optimalEV: number;
  
  // Metadata
  computationMethod: "exact" | "monte_carlo" | "heuristic";
  confidence: number;        // 0.0-1.0 (1.0 for exact)
  rollsRemaining: number;    // 0-2
  computationTimeMs: number;
  cacheHit: boolean;
}

interface CategoryStatistics {
  // Current roll
  probability: number;       // 0.0-1.0
  expectedValue: number;     // Points if scored now
  currentScore: number;      // Points for this roll
  
  // Multi-roll projection (if rollsRemaining > 0)
  futureEV?: number;         // EV after optimal rerolls
  rerollRecommendation?: {
    shouldReroll: boolean;
    keptMask: KeptMask;
    evGain: number;          // Expected improvement
  };
}
```

### 4.4 Decision Recommendation

```typescript
interface DecisionRecommendation {
  // Primary recommendation
  action: "roll" | "reroll" | "score";
  
  // If action is "reroll"
  keptMask?: KeptMask;
  rerollReason?: string;
  expectedImprovement?: number;  // EV gain from reroll
  
  // If action is "score"
  recommendedCategory?: DiceeCategory;
  expectedValue?: number;
  
  // Alternative options
  alternatives: Array<{
    category: DiceeCategory;
    ev: number;
    evDifference: number;     // Difference from optimal
    reasoning: string;
  }>;
  
  // Decision confidence
  confidence: number;          // 0.0-1.0
  reasoning: string;           // Human-readable explanation
  
  // Educational context
  pedagogyLevel: SkillLevel;
  learningTip?: string;
}
```

---

## 5. Event Schema Specification

### 5.1 Base Event Schema

All events inherit from this base:

```typescript
interface BaseGameEvent {
  // Event Identity
  id: UUID;                   // Event unique identifier
  eventType: string;          // Discriminator for event type
  eventVersion: string;       // Schema version (semver)
  sequenceNumber: number;     // Monotonic counter for ordering during replay
  
  // Stream Classification
  streamType: StreamType;     // "domain" | "analysis" | "telemetry"
  
  // Event Source
  eventSource: EventSource;   // "client" | "server" | "engine" | "system"
  
  // Correlation
  traceId: UUID;             // Distributed tracing ID
  causalChain: UUID[];        // Parent event IDs (cause chain)
  
  // Temporal
  timestamp: Timestamp;       // Event creation time (epoch ms)
  
  // Game Context
  gameId: UUID;
  playerId: UUID;
  turnNumber: number;         // 1-13
  rollNumber: number;         // 1-3 within turn
  
  // Execution Metadata (optional)
  computationTimeMs?: number;
  serviceName?: string;       // Which service generated this
  
  // Client Context (optional)
  clientInfo?: {
    userAgent?: string;
    platform?: string;        // "web" | "ios" | "android"
    screenSize?: { width: number; height: number };
  };
}
```

**Validation Rules:**
- `id` must be UUIDv4
- `eventType` must match one of registered event types
- `eventVersion` must be valid semver string
- `sequenceNumber` must be monotonically increasing per game
- `streamType` must be "domain", "analysis", or "telemetry"
- `eventSource` must be "client", "server", "engine", or "system"
- `timestamp` must be within 5 minutes of server time
- `turnNumber` must be 1-13
- `rollNumber` must be 1-3
- `causalChain` must reference existing event IDs

### 5.2 Game Lifecycle Events

#### GameCreatedEvent

```typescript
interface GameCreatedEvent extends BaseGameEvent {
  eventType: "game_created";
  eventVersion: "1.0.0";
  streamType: "domain";
  eventSource: "server";
  
  // Game configuration
  gameMode: "solo" | "multiplayer" | "tutorial";
  playerIds: UUID[];
  settings: {
    rulesVariant?: "standard" | "forced_dicee" | "joker_rules";
    timeLimit?: number;       // Seconds per turn (optional)
    allowUndo?: boolean;
  };
  
  // Host info
  hostPlayerId: UUID;
}
```

#### GameStartedEvent

```typescript
interface GameStartedEvent extends BaseGameEvent {
  eventType: "game_started";
  eventVersion: "1.0.0";
  
  // Turn order
  turnOrder: UUID[];         // Randomized player order
  firstPlayerId: UUID;
  
  // Starting state
  initialScorecards: Record<UUID, Scorecard>;
}
```

#### GameCompletedEvent

```typescript
interface GameCompletedEvent extends BaseGameEvent {
  eventType: "game_completed";
  eventVersion: "1.0.0";
  
  // Final results
  finalScores: Record<UUID, number>;
  winnerIds: UUID[];         // Can be tie
  
  // Game statistics
  totalTurns: number;
  gameDurationMs: number;
  averageDecisionTimeMs: number;
  
  // Completion reason
  reason: "normal" | "abandoned" | "timeout";
}
```

### 5.3 Turn Events

#### RollEvent

```typescript
interface RollEvent extends BaseGameEvent {
  eventType: "roll";
  eventVersion: "2.0.0";
  streamType: "domain";
  eventSource: "client";
  
  // Roll classification
  rollType: RollType;        // "initial" | "reroll"
  
  // Roll result
  diceResult: DiceArray;
  keptMask: KeptMask;        // Which dice were kept from previous
  
  // Pre-roll context (for rerolls)
  preRollDice?: DiceArray;   // Dice before this roll (if reroll)
  intentSignal?: "exploring" | "targeting_category" | "conservative";
  
  // Analysis link (probabilities computed separately)
  analysisId?: UUID;         // Link to AnalysisComputedEvent
  
  // Timing
  timeFromPreviousAction: number;  // ms
}
```

**Validation Rules:**
- `diceResult` must be 5 values, each 1-6
- `keptMask` must be 5 booleans
- If `rollType === "initial"`, `keptMask` should be all false
- If `rollType === "reroll"`, `preRollDice` must be present
- `rollsRemaining` = `3 - rollNumber`

**Design Note:** Probabilities and recommendations are stored in separate `AnalysisComputedEvent` to keep domain events lightweight. This enables:
- Faster game state reconstruction (don't need to load heavy analysis data)
- Ability to recompute analysis without replaying entire game
- Separate retention policies for domain vs. analysis data

#### RerollEvent (DEPRECATED)

**Status:** Deprecated in v2.0.0. Use `RollEvent` with `rollType: "reroll"` instead.

```typescript
// DEPRECATED: For backward compatibility only
interface RerollEvent extends BaseGameEvent {
  eventType: "reroll";
  eventVersion: "1.0.0";
  streamType: "domain";
  
  // Reroll decision
  previousDice: DiceArray;
  keptMask: KeptMask;        // Dice to keep
  newDice: DiceArray;        // Result after reroll
  
  // Decision quality
  wasOptimal: boolean;
  optimalKeptMask: KeptMask;
  evDifference: number;      // Loss from suboptimal choice
  
  // Metadata
  timeToDecision: number;    // ms from roll to reroll
  hintViewed: boolean;
}
```

**Migration:** Systems reading v1 events should map `RerollEvent` → `RollEvent` with:
- `rollType = "reroll"`
- `diceResult = newDice`
- `preRollDice = previousDice`

#### ScoreDecisionEvent

```typescript
interface ScoreDecisionEvent extends BaseGameEvent {
  eventType: "score";
  eventVersion: "1.1.0";
  
  // Scoring decision
  chosenCategory: DiceeCategory;
  pointsEarned: number;
  
  // Decision quality analysis
  expectedValue: number;
  optimalCategory: DiceeCategory;
  optimalEV: number;
  evDifference: number;      // Optimal EV - Actual EV
  decisionQuality: DecisionQuality;
  
  // Scorecard update
  previousScorecard: Scorecard;
  updatedScorecard: Scorecard;
  
  // Behavioral telemetry
  timeToDecision: number;    // ms from final roll to score
  categoriesConsidered: DiceeCategory[];  // Hover sequence
  backtrackCount: number;    // Number of category changes
  hintRequested: boolean;
  
  // Educational context
  learningTip?: string;
  conceptsApplied?: string[];  // ["expected_value", "probability"]
}
```

**Validation Rules:**
- `chosenCategory` must not be already scored
- `pointsEarned` must match scoring rules for category
- `updatedScorecard` must reflect new score correctly
- `evDifference` must be non-negative (optimal >= actual)

### 5.4 Analysis Events

Analysis events contain computational results that can be recomputed from domain events. They are stored separately with shorter retention periods.

#### AnalysisComputedEvent

```typescript
interface AnalysisComputedEvent extends BaseGameEvent {
  eventType: "analysis_computed";
  eventVersion: "1.0.0";
  streamType: "analysis";
  eventSource: "engine";
  
  // Analysis identifier (linked from RollEvent)
  analysisId: UUID;
  
  // Source event this analysis is for
  sourceEventId: UUID;       // The RollEvent this analyzes
  
  // Computed probabilities
  probabilities: ProbabilityVector;
  
  // Decision recommendations
  recommendations: DecisionRecommendation[];
  
  // Computation metadata
  computationMethod: "exact" | "monte_carlo" | "heuristic";
  confidence: number;        // 0.0-1.0
  cacheHit: boolean;
}
```

**Validation Rules:**
- `analysisId` must match `analysisId` field in corresponding `RollEvent`
- `sourceEventId` must reference a valid `RollEvent`
- `computationMethod` determines `confidence` range:
  - "exact" must have `confidence = 1.0`
  - "monte_carlo" must have `confidence >= 0.95`
  - "heuristic" may have lower confidence

#### RecommendationEvent (Optional Future Extension)

```typescript
interface RecommendationEvent extends BaseGameEvent {
  eventType: "recommendation";
  eventVersion: "1.0.0";
  streamType: "analysis";
  eventSource: "server";
  
  // Context
  gameStateSnapshot: {
    diceResult: DiceArray;
    scorecard: Scorecard;
    rollsRemaining: number;
  };
  
  // Recommendation
  recommendation: DecisionRecommendation;
  
  // Adaptive context
  playerSkillLevel: SkillLevel;
  pedagogyStrategy: string;
}
```

**Design Rationale:**

Separating analysis into its own events provides:

1. **Storage efficiency** — Domain events stay small (~500 bytes), analysis events are larger (~5-10KB)
2. **Replay performance** — Reconstructing game state doesn't require loading analysis
3. **Recomputation** — Can delete and regenerate analysis without losing game data
4. **Different retention** — Keep domain events forever, analysis events for 90 days
5. **Query optimization** — Separate indexes for gameplay vs. analytics queries

### 5.5 UI Telemetry Events

Telemetry events capture learning metrics and UX behavior. These are stored with the shortest retention (30 days) and are optimized for analytics queries.

#### HoverEvent

```typescript
interface HoverEvent extends BaseGameEvent {
  eventType: "hover";
  eventVersion: "1.0.0";
  streamType: "telemetry";
  eventSource: "client";
  
  // Hover target
  categoryHovered: DiceeCategory;
  hoverDuration: number;     // ms
  
  // Contextual calculation
  wouldScore: number;
  currentEV: number;
  isOptimal: boolean;
  
  // Sequence tracking
  hoverSequence: number;     // Nth hover in this turn
}
```

#### PredictionEvent

```typescript
interface PredictionEvent extends BaseGameEvent {
  eventType: "prediction";
  eventVersion: "1.0.0";
  streamType: "telemetry";
  eventSource: "client";
  
  // Player prediction
  predictedCategory: DiceeCategory;
  predictedProbability: number;  // 0.0-1.0
  confidenceLevel: "low" | "medium" | "high";
  
  // Actual values
  actualProbability: number;
  accuracyDelta: number;     // abs(predicted - actual)
  
  // Reward calculation
  predictionScore: number;   // Gamification points
}
```

#### HintRequestedEvent

```typescript
interface HintRequestedEvent extends BaseGameEvent {
  eventType: "hint_requested";
  eventVersion: "1.0.0";
  streamType: "telemetry";
  eventSource: "client";
  
  // Hint context
  currentDice: DiceArray;
  availableCategories: DiceeCategory[];
  
  // Hint delivered
  hintType: "optimal_category" | "reroll_strategy" | "probability_explanation";
  hintContent: string;
  
  // Learning impact
  playerSkillLevel: SkillLevel;
  conceptsIntroduced: string[];
}
```

### 5.6 Error Events

```typescript
interface ErrorEvent extends BaseGameEvent {
  eventType: "error";
  eventVersion: "1.0.0";
  streamType: "domain";      // Errors are part of audit trail
  eventSource: "system";
  
  // Error details
  errorCode: string;         // "INVALID_MOVE", "TIMEOUT", etc.
  errorMessage: string;
  severity: "warning" | "error" | "fatal";
  
  // Context
  failedAction: string;
  failedPayload?: any;
  
  // Recovery
  recovered: boolean;
  recoveryAction?: string;
}
```

---

## 6. API Request/Response Contracts

### 6.1 Probability Calculation Endpoint

**POST** `/api/v1/stats/probabilities`

**Request:**

```typescript
interface ProbabilityRequest {
  // Current state
  diceResult: DiceArray;
  keptMask: KeptMask;
  rollsRemaining: number;    // 0-2
  
  // Game context
  availableCategories: DiceeCategory[];
  currentScorecard: Scorecard;
  
  // Optional context
  opponentScores?: number[];
  skillLevel?: SkillLevel;
  
  // Computation preferences
  computationMethod?: "exact" | "monte_carlo" | "auto";
  maxComputationTimeMs?: number;  // Timeout hint
}
```

**Response:**

```typescript
interface ProbabilityResponse {
  // Calculation result
  probabilities: ProbabilityVector;
  
  // Metadata
  requestId: UUID;
  computationTimeMs: number;
  cacheHit: boolean;
  
  // Status
  success: boolean;
  error?: ErrorDetail;
}
```

### 5.2 Decision Recommendation Endpoint

**POST** `/api/v1/stats/recommendation`

**Request:**

```typescript
interface RecommendationRequest extends ProbabilityRequest {
  // Additional context for recommendations
  skillLevel: SkillLevel;
  showAlternatives: boolean;
  explanationDepth: "minimal" | "standard" | "detailed";
  
  // Player history (optional)
  recentDecisions?: ScoreDecisionEvent[];
}
```

**Response:**

```typescript
interface RecommendationResponse {
  // Primary recommendation
  recommendation: DecisionRecommendation;
  
  // Supporting data
  probabilities: ProbabilityVector;
  
  // Metadata
  requestId: UUID;
  computationTimeMs: number;
  
  // Status
  success: boolean;
  error?: ErrorDetail;
}
```

### 5.3 Decision Evaluation Endpoint

**POST** `/api/v1/stats/evaluate`

**Request:**

```typescript
interface EvaluationRequest {
  // Decision to evaluate
  gameState: {
    diceResult: DiceArray;
    rollNumber: number;
    availableCategories: DiceeCategory[];
    scorecard: Scorecard;
  };
  
  // Player's choice
  chosenCategory: DiceeCategory;
  
  // Context
  timeToDecision: number;    // ms
  skillLevel: SkillLevel;
}
```

**Response:**

```typescript
interface EvaluationResponse {
  // Quality assessment
  decisionQuality: DecisionQuality;
  pointsEarned: number;
  expectedValue: number;
  
  // Optimal comparison
  optimalCategory: DiceeCategory;
  optimalEV: number;
  evDifference: number;
  evPercentageLoss: number;  // (optimal - actual) / optimal
  
  // Feedback
  feedback: {
    summary: string;
    reasoning: string;
    learningTip?: string;
    mistakeCategory?: "probability" | "expected_value" | "strategy";
  };
  
  // Metadata
  requestId: UUID;
  success: boolean;
  error?: ErrorDetail;
}
```

### 5.4 Game State Query Endpoint

**GET** `/api/v1/games/{gameId}`

**Response:**

```typescript
interface GameStateResponse {
  // Game info
  gameId: UUID;
  status: GameStatus;
  mode: "solo" | "multiplayer" | "tutorial";
  
  // Players
  players: Array<{
    playerId: UUID;
    displayName: string;
    scorecard: Scorecard;
    isCurrentPlayer: boolean;
  }>;
  
  // Current turn
  currentTurn: {
    playerId: UUID;
    turnNumber: number;
    rollNumber: number;
    currentDice?: DiceArray;
    keptMask?: KeptMask;
    phase: TurnPhase;
  };
  
  // Event stream
  events: BaseGameEvent[];   // Full history
  
  // Timestamps
  createdAt: ISODateTime;
  startedAt?: ISODateTime;
  completedAt?: ISODateTime;
  
  // Metadata
  success: boolean;
  error?: ErrorDetail;
}
```

---

## 7. WebSocket Protocol

### 6.1 Connection Lifecycle

**Connection URL:** `wss://api.dicee.app/v1/game/{gameId}`

**Authentication:** JWT token in header or query param

```typescript
// Connection
const ws = new WebSocket(
  'wss://api.dicee.app/v1/game/123e4567',
  { headers: { 'Authorization': 'Bearer <jwt>' } }
);
```

### 6.2 Client → Server Messages

#### Join Game

```typescript
interface JoinMessage {
  type: "join";
  playerId: UUID;
  clientVersion: string;      // "1.0.0"
  reconnect: boolean;         // Resume existing session
}
```

#### Roll Dice

```typescript
interface RollMessage {
  type: "roll";
  keptMask?: KeptMask;       // Omit for initial roll
  requestProbabilities: boolean;
}
```

#### Score Category

```typescript
interface ScoreMessage {
  type: "score";
  category: DiceeCategory;
}
```

#### Request Hint

```typescript
interface HintRequestMessage {
  type: "request_hint";
  explanationDepth: "minimal" | "standard" | "detailed";
}
```

#### Hover Category (telemetry)

```typescript
interface HoverMessage {
  type: "hover";
  category: DiceeCategory;
  hoverStartTime: Timestamp;
}
```

### 6.3 Server → Client Messages

#### Game State Update

```typescript
interface StateUpdateMessage {
  type: "state_update";
  gameState: GameStateResponse;
  timestamp: Timestamp;
}
```

#### Roll Result

```typescript
interface RollResultMessage {
  type: "roll_result";
  event: RollEvent;          // Full event with probabilities
}
```

#### Turn Changed

```typescript
interface TurnChangedMessage {
  type: "turn_changed";
  newPlayerId: UUID;
  playerName: string;
  turnNumber: number;
}
```

#### Hint Delivered

```typescript
interface HintMessage {
  type: "hint";
  recommendation: DecisionRecommendation;
}
```

#### Error

```typescript
interface ErrorMessage {
  type: "error";
  errorCode: string;
  message: string;
  severity: "warning" | "error" | "fatal";
  recoverable: boolean;
}
```

#### Connection Status

```typescript
interface ConnectionStatusMessage {
  type: "connection_status";
  status: "connected" | "reconnecting" | "disconnected";
  reason?: string;
}
```

---

## 8. Data Validation Rules

### 7.1 Dice Validation

```typescript
function validateDiceArray(dice: any): dice is DiceArray {
  return (
    Array.isArray(dice) &&
    dice.length === 5 &&
    dice.every(d => Number.isInteger(d) && d >= 1 && d <= 6)
  );
}

function validateKeptMask(mask: any): mask is KeptMask {
  return (
    Array.isArray(mask) &&
    mask.length === 5 &&
    mask.every(m => typeof m === 'boolean')
  );
}
```

### 7.2 Scorecard Validation

```typescript
function validateScorecard(scorecard: Scorecard): ValidationResult {
  const errors: string[] = [];
  
  // Upper section validation
  const upperScores = [
    scorecard.ones, scorecard.twos, scorecard.threes,
    scorecard.fours, scorecard.fives, scorecard.sixes
  ].filter(s => s !== undefined);
  
  const upperSum = upperScores.reduce((a, b) => a! + b!, 0);
  
  if (upperSum !== scorecard.upperSubtotal) {
    errors.push(`Upper subtotal mismatch: ${upperSum} != ${scorecard.upperSubtotal}`);
  }
  
  // Upper bonus validation
  const expectedBonus = scorecard.upperSubtotal >= 63 ? 35 : 0;
  if (scorecard.upperBonus !== expectedBonus) {
    errors.push(`Upper bonus should be ${expectedBonus}, got ${scorecard.upperBonus}`);
  }
  
  // Category value validation
  if (scorecard.fullHouse !== undefined && ![0, 25].includes(scorecard.fullHouse)) {
    errors.push(`Full house must be 0 or 25, got ${scorecard.fullHouse}`);
  }
  
  if (scorecard.smallStraight !== undefined && ![0, 30].includes(scorecard.smallStraight)) {
    errors.push(`Small straight must be 0 or 30`);
  }
  
  if (scorecard.largeStraight !== undefined && ![0, 40].includes(scorecard.largeStraight)) {
    errors.push(`Large straight must be 0 or 40`);
  }
  
  if (scorecard.dicee !== undefined && ![0, 50].includes(scorecard.dicee)) {
    errors.push(`Dicee must be 0 or 50`);
  }
  
  // Dicee bonus validation (must be multiple of 100)
  if (scorecard.diceeBonus % 100 !== 0) {
    errors.push(`Dicee bonus must be multiple of 100`);
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

### 7.3 Event Validation

```typescript
function validateEvent(event: BaseGameEvent): ValidationResult {
  const errors: string[] = [];
  
  // UUID format validation
  if (!isValidUUID(event.id)) {
    errors.push(`Invalid event ID format`);
  }
  
  if (!isValidUUID(event.gameId)) {
    errors.push(`Invalid game ID format`);
  }
  
  if (!isValidUUID(event.playerId)) {
    errors.push(`Invalid player ID format`);
  }
  
  // Version validation
  if (!isValidSemver(event.eventVersion)) {
    errors.push(`Invalid event version: ${event.eventVersion}`);
  }
  
  // Range validation
  if (event.turnNumber < 1 || event.turnNumber > 13) {
    errors.push(`Turn number must be 1-13, got ${event.turnNumber}`);
  }
  
  if (event.rollNumber < 1 || event.rollNumber > 3) {
    errors.push(`Roll number must be 1-3, got ${event.rollNumber}`);
  }
  
  // Timestamp validation (within 5 minutes of server time)
  const now = Date.now();
  const timeDiff = Math.abs(now - event.timestamp);
  const fiveMinutes = 5 * 60 * 1000;
  
  if (timeDiff > fiveMinutes) {
    errors.push(`Timestamp too far from server time: ${timeDiff}ms`);
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

### 7.4 Probability Vector Validation

```typescript
function validateProbabilityVector(pv: ProbabilityVector): ValidationResult {
  const errors: string[] = [];
  
  // Probability bounds
  for (const [category, stats] of Object.entries(pv.categories)) {
    if (stats.probability < 0 || stats.probability > 1) {
      errors.push(`${category} probability out of bounds: ${stats.probability}`);
    }
    
    // Exact computation should have confidence = 1.0
    if (pv.computationMethod === "exact" && pv.confidence !== 1.0) {
      errors.push(`Exact computation should have confidence 1.0`);
    }
  }
  
  // Optimal category must exist
  if (!pv.categories[pv.optimalCategory]) {
    errors.push(`Optimal category ${pv.optimalCategory} not in categories`);
  }
  
  // Optimal EV must match category EV
  const optimalStats = pv.categories[pv.optimalCategory];
  if (Math.abs(optimalStats.expectedValue - pv.optimalEV) > 0.01) {
    errors.push(`Optimal EV mismatch`);
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}
```

---

## 9. Game Integrity Rules

These rules define **illegal game states** that must be prevented by validation. Violating these rules indicates a bug in game logic or potential cheating.

### 9.1 Turn Sequencing Rules

**Rule 9.1.1: Maximum Rolls Per Turn**
- Each turn must have exactly 1-3 rolls
- After 3 rolls, player MUST score
- Attempting a 4th roll is invalid

```typescript
function validateRollCount(events: RollEvent[]): boolean {
  const rollsThisTurn = events.filter(e => 
    e.turnNumber === currentTurn && e.rollType === "roll"
  ).length;
  return rollsThisTurn <= 3;
}
```

**Rule 9.1.2: Turn Advancement**
- Turn number increments only after `ScoreDecisionEvent`
- Cannot skip turns
- Cannot score twice in one turn

```typescript
function validateTurnAdvancement(events: GameEvent[]): boolean {
  const scoreEvents = events.filter(e => e.eventType === "score");
  
  for (let i = 0; i < scoreEvents.length; i++) {
    const expectedTurn = i + 1;
    if (scoreEvents[i].turnNumber !== expectedTurn) {
      return false;  // Turn sequence violation
    }
  }
  return true;
}
```

**Rule 9.1.3: Total Turns Per Game**
- Exactly 13 scoring decisions per player per game
- Game must complete after 13 turns
- Early completion requires explicit `GameCompletedEvent` with reason "abandoned"

### 9.2 Category Uniqueness Rules

**Rule 9.2.1: Category Scored Once**
- Each category can be scored exactly once per player per game
- Attempting to score an already-filled category is invalid

```typescript
function validateCategoryUniqueness(
  scorecard: Scorecard,
  chosenCategory: DiceeCategory
): boolean {
  return scorecard[chosenCategory] === undefined;
}
```

**Rule 9.2.2: Category Availability Consistency**
- `categoriesRemaining` in scorecard must match unscored categories
- Length decreases by exactly 1 after each score

```typescript
function validateCategoryList(scorecard: Scorecard): boolean {
  const scoredCount = Object.keys(scorecard).filter(
    k => scorecard[k as DiceeCategory] !== undefined
  ).length;
  
  const remainingCount = scorecard.categoriesRemaining.length;
  
  return scoredCount + remainingCount === 13;
}
```

### 9.3 Roll Validity Rules

**Rule 9.3.1: Kept Mask Consistency**
- For `rollType === "initial"`, `keptMask` must be all `false`
- For `rollType === "reroll"`, `keptMask` must have at least one `false` (otherwise, why reroll?)

**Rule 9.3.2: Dice Result Changes**
- After reroll, only unkept dice may change values
- Kept dice must match `preRollDice` values

```typescript
function validateReroll(
  preRollDice: DiceArray,
  keptMask: KeptMask,
  newDice: DiceArray
): boolean {
  for (let i = 0; i < 5; i++) {
    if (keptMask[i] && preRollDice[i] !== newDice[i]) {
      return false;  // Kept die changed value
    }
  }
  return true;
}
```

### 9.4 Scorecard Arithmetic Rules

**Rule 9.4.1: Score Calculation Correctness**
- `pointsEarned` must match the scoring function for the category and dice

```typescript
function validateScore(
  category: DiceeCategory,
  dice: DiceArray,
  pointsEarned: number
): boolean {
  const expected = SCORING_RULES[category](dice);
  return pointsEarned === expected;
}
```

**Rule 9.4.2: Upper Bonus Correctness**
- Upper bonus = 35 if `upperSubtotal >= 63`, else 0
- This is recalculated after each upper section score

```typescript
function validateUpperBonus(scorecard: Scorecard): boolean {
  const expected = scorecard.upperSubtotal >= 63 ? 35 : 0;
  return scorecard.upperBonus === expected;
}
```

**Rule 9.4.3: Grand Total Correctness**
- `grandTotal = upperTotal + lowerTotal`
- Must be recalculated after each score

### 9.5 Event Ordering Rules

**Rule 9.5.1: Causal Chain Integrity**
- Every event's `causalChain` must reference events with earlier `sequenceNumber`
- No circular dependencies
- Events cannot cause themselves

```typescript
function validateCausalChain(
  event: BaseGameEvent,
  allEvents: Map<UUID, BaseGameEvent>
): boolean {
  for (const parentId of event.causalChain) {
    const parent = allEvents.get(parentId);
    if (!parent || parent.sequenceNumber >= event.sequenceNumber) {
      return false;
    }
  }
  return true;
}
```

**Rule 9.5.2: Sequence Number Monotonicity**
- `sequenceNumber` must increase monotonically within a game
- No gaps allowed
- Starts at 1

```typescript
function validateSequenceNumbers(events: BaseGameEvent[]): boolean {
  for (let i = 0; i < events.length; i++) {
    if (events[i].sequenceNumber !== i + 1) {
      return false;
    }
  }
  return true;
}
```

### 9.6 Timestamp Consistency Rules

**Rule 9.6.1: Temporal Ordering**
- Events must be ordered by timestamp
- Later `sequenceNumber` implies later or equal timestamp

```typescript
function validateTimestamps(events: BaseGameEvent[]): boolean {
  for (let i = 1; i < events.length; i++) {
    if (events[i].timestamp < events[i-1].timestamp) {
      return false;
    }
  }
  return true;
}
```

---

## 10. Safety Invariants

These are mathematical properties that must hold for all valid data. Violating an invariant indicates corrupted data or calculation errors.

### 10.1 Probability Invariants

**Invariant 10.1.1: Probability Bounds**

For all categories in a `ProbabilityVector`:

```
∀ category: 0 ≤ P(category) ≤ 1
```

```typescript
function checkProbabilityBounds(pv: ProbabilityVector): boolean {
  return Object.values(pv.categories).every(
    stats => stats.probability >= 0 && stats.probability <= 1
  );
}
```

**Invariant 10.1.2: Probability Sum (Upper Bound)**

For disjoint categories (all lower section categories except Dicee bonus):

```
Σ P(category) ≤ 1.0 + ε  (where ε accounts for floating point)
```

Note: Sum can exceed 1.0 because categories can overlap (e.g., three-of-a-kind and full house can both match same dice).

**Invariant 10.1.3: Exact Computation Confidence**

```
computationMethod === "exact" ⟹ confidence === 1.0
```

### 10.2 Expected Value Invariants

**Invariant 10.2.1: EV Non-Negativity**

Expected values must be non-negative (you can't lose points):

```
∀ category: EV(category) ≥ 0
```

**Invariant 10.2.2: EV Bounds by Category**

```
EV(ones) ∈ [0, 5]      // Max 5 ones
EV(twos) ∈ [0, 10]     // Max 5 twos
...
EV(sixes) ∈ [0, 30]    // Max 5 sixes
EV(three_of_kind) ∈ [0, 30]  // Max sum
EV(four_of_kind) ∈ [0, 30]
EV(full_house) ∈ {0, 25}      // Binary
EV(small_straight) ∈ {0, 30}
EV(large_straight) ∈ {0, 40}
EV(dicee) ∈ {0, 50}
EV(chance) ∈ [5, 30]   // Sum of 5 dice
```

**Invariant 10.2.3: Optimal EV is Maximum**

```
EV(optimal_category) ≥ EV(any_other_category)
```

```typescript
function validateOptimalEV(pv: ProbabilityVector): boolean {
  const optimalEV = pv.optimalEV;
  
  return Object.values(pv.categories).every(
    stats => stats.expectedValue <= optimalEV + 0.01  // Float tolerance
  );
}
```

**Invariant 10.2.4: EV Monotonicity with Rolls**

Expected value should not decrease with more rolls remaining:

```
EV(state, rolls_remaining=2) ≥ EV(state, rolls_remaining=1) ≥ EV(state, rolls_remaining=0)
```

### 10.3 Scorecard Invariants

**Invariant 10.3.1: Score Non-Negativity**

All scores must be non-negative:

```
∀ category: scorecard[category] ≥ 0
```

**Invariant 10.3.2: Upper Section Arithmetic**

```
upperSubtotal = sum(ones, twos, threes, fours, fives, sixes)
upperBonus = (upperSubtotal ≥ 63) ? 35 : 0
upperTotal = upperSubtotal + upperBonus
```

**Invariant 10.3.3: Lower Section Arithmetic**

```
lowerTotal = sum(all lower section categories) + diceeBonus
```

**Invariant 10.3.4: Grand Total**

```
grandTotal = upperTotal + lowerTotal
```

**Invariant 10.3.5: Dicee Bonus Multiplicity**

```
diceeBonus % 100 === 0
```

(Bonus is earned in 100-point increments)

**Invariant 10.3.6: Fixed-Value Categories**

```
full_house ∈ {0, 25}
small_straight ∈ {0, 30}
large_straight ∈ {0, 40}
dicee ∈ {0, 50}
```

### 10.4 Game State Invariants

**Invariant 10.4.1: Turn Bounds**

```
1 ≤ turnNumber ≤ 13
```

**Invariant 10.4.2: Roll Bounds**

```
1 ≤ rollNumber ≤ 3
```

**Invariant 10.4.3: Categories Remaining**

```
categoriesRemaining.length = 13 - turnsCompleted
```

**Invariant 10.4.4: Game Completion**

```
status === "completed" ⟹ turnsCompleted === 13
```

### 10.5 Event Stream Invariants

**Invariant 10.5.1: Event Uniqueness**

All event IDs must be unique:

```
∀ i, j: events[i].id ≠ events[j].id  (for i ≠ j)
```

**Invariant 10.5.2: Sequence Continuity**

```
events are ordered by sequenceNumber with no gaps
```

**Invariant 10.5.3: Game Replay Determinism**

Replaying the same event stream must produce the same final game state:

```
replay(events) = replay(events)  (idempotent)
```

### 10.6 Decision Quality Invariants

**Invariant 10.6.1: EV Difference Non-Negativity**

```
evDifference = optimalEV - actualEV ≥ 0
```

(Optimal is always better than or equal to actual choice)

**Invariant 10.6.2: Decision Quality Consistency**

```
evDifference === 0 ⟹ decisionQuality === "optimal"
evDifference ≤ 0.05 * optimalEV ⟹ decisionQuality ∈ {"optimal", "excellent"}
```

### 10.7 Testing Invariants

All invariants should be:
1. **Tested in unit tests** with property-based testing
2. **Checked in assertions** during development
3. **Monitored in production** with alerts on violations
4. **Documented in code** with references to this RFC

```typescript
// Example assertion
function assertInvariants(gameState: GameState): void {
  assert(gameState.turnNumber >= 1 && gameState.turnNumber <= 13);
  assert(gameState.rollNumber >= 1 && gameState.rollNumber <= 3);
  
  const scorecard = gameState.currentPlayer.scorecard;
  assert(validateUpperBonus(scorecard));
  assert(validateGrandTotal(scorecard));
  
  // ... all invariants
}
```

---

## 11. Error Schema

### 11.1 Error Response Format

```typescript
interface ErrorDetail {
  // Error identification
  code: string;              // Machine-readable code
  message: string;           // Human-readable message
  severity: "warning" | "error" | "fatal";
  
  // Context
  timestamp: Timestamp;
  requestId?: UUID;
  traceId?: UUID;
  
  // Details
  details?: {
    field?: string;          // Which field caused error
    constraint?: string;     // Which validation failed
    expected?: any;          // Expected value
    actual?: any;            // Actual value
  };
  
  // Recovery
  recoverable: boolean;
  retryAfter?: number;       // Seconds to wait before retry
  suggestedAction?: string;
}
```

### 11.2 Standard Error Codes

**Client Errors (4xx):**

```typescript
const ErrorCodes = {
  // Validation errors
  INVALID_DICE: "ERR_INVALID_DICE",
  INVALID_CATEGORY: "ERR_INVALID_CATEGORY",
  CATEGORY_ALREADY_SCORED: "ERR_CATEGORY_SCORED",
  INVALID_TURN: "ERR_INVALID_TURN",
  
  // Game state errors
  GAME_NOT_FOUND: "ERR_GAME_NOT_FOUND",
  GAME_NOT_STARTED: "ERR_GAME_NOT_STARTED",
  GAME_COMPLETED: "ERR_GAME_COMPLETED",
  NOT_YOUR_TURN: "ERR_NOT_YOUR_TURN",
  
  // Auth errors
  UNAUTHORIZED: "ERR_UNAUTHORIZED",
  FORBIDDEN: "ERR_FORBIDDEN",
  SESSION_EXPIRED: "ERR_SESSION_EXPIRED",
  
  // Rate limiting
  RATE_LIMIT_EXCEEDED: "ERR_RATE_LIMIT",
} as const;
```

**Server Errors (5xx):**

```typescript
const ServerErrorCodes = {
  INTERNAL_ERROR: "ERR_INTERNAL",
  DATABASE_ERROR: "ERR_DATABASE",
  COMPUTATION_TIMEOUT: "ERR_TIMEOUT",
  SERVICE_UNAVAILABLE: "ERR_SERVICE_DOWN",
  CACHE_ERROR: "ERR_CACHE",
} as const;
```

### 11.3 Error Response Examples

**Validation Error:**

```json
{
  "success": false,
  "error": {
    "code": "ERR_INVALID_DICE",
    "message": "Dice array must contain exactly 5 values between 1 and 6",
    "severity": "error",
    "timestamp": 1698765432000,
    "requestId": "req_123e4567",
    "details": {
      "field": "diceResult",
      "constraint": "length_and_range",
      "expected": "Array of 5 integers (1-6)",
      "actual": "[1, 2, 3, 7]"
    },
    "recoverable": true,
    "suggestedAction": "Check dice values and retry"
  }
}
```

**Game State Error:**

```json
{
  "success": false,
  "error": {
    "code": "ERR_NOT_YOUR_TURN",
    "message": "Cannot perform action: it is not your turn",
    "severity": "warning",
    "timestamp": 1698765432000,
    "details": {
      "currentPlayerId": "player_456",
      "yourPlayerId": "player_789"
    },
    "recoverable": false,
    "suggestedAction": "Wait for your turn"
  }
}
```

---

## 12. Schema Evolution Guidelines

### 12.1 Adding New Fields (Minor Version)

**DO:**
- ✅ Add optional fields with default values
- ✅ Add new event types
- ✅ Add new enum values at the end

**Example:**

```typescript
// v1.0.0
interface RollEvent {
  eventType: "roll";
  diceResult: DiceArray;
}

// v1.1.0 - SAFE: Added optional field
interface RollEvent {
  eventType: "roll";
  eventVersion: "1.1.0";
  diceResult: DiceArray;
  intentSignal?: "exploring" | "targeting_category";  // NEW
}
```

### 12.2 Breaking Changes (Major Version)

**REQUIRES MAJOR BUMP:**
- ❌ Remove field
- ❌ Rename field
- ❌ Change field type
- ❌ Make optional field required
- ❌ Change enum values
- ❌ Change validation rules (stricter)

**Example:**

```typescript
// v1.x.x
interface RollEvent {
  diceResult: number[];  // Any length array
}

// v2.0.0 - BREAKING: Changed to fixed-length tuple
interface RollEvent {
  eventVersion: "2.0.0";
  diceResult: DiceArray;  // Exactly 5 elements
}
```

### 12.3 Deprecation Process

**Step 1: Announce deprecation**
- Add `@deprecated` JSDoc comment
- Add deprecation notice in release notes
- Set deprecation date (minimum 6 months)

```typescript
interface RollEvent {
  /**
   * @deprecated Use `diceResult` instead. Will be removed in v2.0.0
   */
  dice?: number[];
  
  diceResult: DiceArray;  // New field
}
```

**Step 2: Support both fields during transition**
- Accept both old and new field
- Write only new field
- Log warnings when old field used

**Step 3: Remove deprecated field in next major version**

---

## 13. Implementation Checklist

### 13.1 Type Definitions

- [ ] Generate TypeScript types from this spec
- [ ] Generate Rust types for WASM engine
- [ ] Generate Python Pydantic models
- [ ] Generate JSON Schema for validation
- [ ] Publish types to npm (`@dicee/types`)

### 13.2 Validation

- [ ] Implement validation functions for all schemas
- [ ] Add JSON Schema validation middleware
- [ ] Create validation test suite (>95% coverage)
- [ ] Add property-based tests for invariants

### 13.3 Versioning

- [ ] Implement schema version registry
- [ ] Add version compatibility matrix
- [ ] Create migration utilities
- [ ] Document upgrade paths

### 13.4 API Implementation

- [ ] Implement all REST endpoints
- [ ] Implement WebSocket protocol
- [ ] Add request/response validation
- [ ] Add error handling middleware
- [ ] Add rate limiting

### 13.5 Testing

- [ ] Contract tests between services
- [ ] Integration tests for full flows
- [ ] Load testing for all endpoints
- [ ] WebSocket connection stability tests

### 13.6 Documentation

- [ ] Generate API documentation (OpenAPI)
- [ ] Create integration guide
- [ ] Document error codes
- [ ] Provide code examples

---

## 14. Appendices

### Appendix A: Complete Event Type Registry

```typescript
const EventTypes = {
  // Game lifecycle
  GAME_CREATED: "game_created",
  GAME_STARTED: "game_started",
  GAME_COMPLETED: "game_completed",
  GAME_ABANDONED: "game_abandoned",
  
  // Turn events
  ROLL: "roll",
  REROLL: "reroll",
  SCORE: "score",
  
  // UI telemetry
  HOVER: "hover",
  PREDICTION: "prediction",
  HINT_REQUESTED: "hint_requested",
  
  // System
  ERROR: "error",
  CONNECTION: "connection",
} as const;
```

### Appendix B: Scoring Rules Reference

```typescript
const SCORING_RULES = {
  // Upper section
  ones: (dice: DiceArray) => dice.filter(d => d === 1).length * 1,
  twos: (dice: DiceArray) => dice.filter(d => d === 2).length * 2,
  threes: (dice: DiceArray) => dice.filter(d => d === 3).length * 3,
  fours: (dice: DiceArray) => dice.filter(d => d === 4).length * 4,
  fives: (dice: DiceArray) => dice.filter(d => d === 5).length * 5,
  sixes: (dice: DiceArray) => dice.filter(d => d === 6).length * 6,
  
  // Lower section
  threeOfKind: (dice: DiceArray) => hasNOfKind(dice, 3) ? sum(dice) : 0,
  fourOfKind: (dice: DiceArray) => hasNOfKind(dice, 4) ? sum(dice) : 0,
  fullHouse: (dice: DiceArray) => isFullHouse(dice) ? 25 : 0,
  smallStraight: (dice: DiceArray) => hasSmallStraight(dice) ? 30 : 0,
  largeStraight: (dice: DiceArray) => hasLargeStraight(dice) ? 40 : 0,
  dicee: (dice: DiceArray) => hasNOfKind(dice, 5) ? 50 : 0,
  chance: (dice: DiceArray) => sum(dice),
  
  // Bonuses
  upperBonus: (upperSum: number) => upperSum >= 63 ? 35 : 0,
  diceeBonus: () => 100,  // Per additional Dicee
};
```

### Appendix C: Sample Event Flow

```typescript
// Complete game flow example

// 1. Game created
const gameCreated: GameCreatedEvent = {
  id: "evt_001",
  eventType: "game_created",
  eventVersion: "1.0.0",
  traceId: "trace_abc",
  causalChain: [],
  timestamp: 1698765432000,
  gameId: "game_123",
  playerId: "player_456",
  turnNumber: 0,
  rollNumber: 0,
  mode: "solo",
  playerIds: ["player_456"],
  settings: { rulesVariant: "standard" },
  hostPlayerId: "player_456"
};

// 2. Game started
const gameStarted: GameStartedEvent = {
  // ... base fields
  eventType: "game_started",
  causalChain: ["evt_001"],
  turnOrder: ["player_456"],
  firstPlayerId: "player_456",
  initialScorecards: { /* ... */ }
};

// 3. First roll
const firstRoll: RollEvent = {
  // ... base fields
  eventType: "roll",
  turnNumber: 1,
  rollNumber: 1,
  causalChain: ["evt_002"],
  diceResult: [3, 3, 5, 5, 6],
  keptMask: [false, false, false, false, false],
  probabilities: { /* computed */ },
  recommendations: [ /* computed */ ],
  timeFromPreviousAction: 2500
};

// 4. Reroll keeping 3s
const reroll: RerollEvent = {
  // ... base fields
  eventType: "reroll",
  turnNumber: 1,
  rollNumber: 2,
  causalChain: ["evt_003"],
  previousDice: [3, 3, 5, 5, 6],
  keptMask: [true, true, false, false, false],
  newDice: [3, 3, 3, 4, 5],
  wasOptimal: true,
  optimalKeptMask: [true, true, false, false, false],
  evDifference: 0,
  timeToDecision: 3200,
  hintViewed: false
};

// 5. Score three of a kind
const score: ScoreDecisionEvent = {
  // ... base fields
  eventType: "score",
  turnNumber: 1,
  rollNumber: 2,
  causalChain: ["evt_004"],
  chosenCategory: "three_of_kind",
  pointsEarned: 18,
  expectedValue: 18,
  optimalCategory: "three_of_kind",
  optimalEV: 18,
  evDifference: 0,
  decisionQuality: "optimal",
  previousScorecard: { /* before */ },
  updatedScorecard: { /* after */ },
  timeToDecision: 1800,
  categoriesConsidered: ["threes", "three_of_kind"],
  backtrackCount: 1,
  hintRequested: false
};
```

### Appendix D: Cross-Service Type Sharing

**Package Structure:**

```
@dicee/types/
├── index.ts              # Main export
├── events/
│   ├── base.ts
│   ├── game-lifecycle.ts
│   ├── turn-events.ts
│   └── telemetry.ts
├── api/
│   ├── requests.ts
│   ├── responses.ts
│   └── websocket.ts
├── domain/
│   ├── dice.ts
│   ├── scorecard.ts
│   ├── probability.ts
│   └── decision.ts
└── validation/
    ├── validators.ts
    └── schemas.json
```

**Usage:**

```typescript
// In any service
import {
  RollEvent,
  ProbabilityRequest,
  validateDiceArray
} from '@dicee/types';

// Type safety across services
function handleRoll(event: RollEvent): ProbabilityResponse {
  if (!validateDiceArray(event.diceResult)) {
    throw new ValidationError("Invalid dice");
  }
  // ...
}
```

---

## Next Steps

1. **Review this RFC** with the team
2. **Generate types** for all languages (TS, Rust, Python)
3. **Implement validation** functions with tests
4. **Create RFC-004** (Game Loop & Mechanics) using these contracts
5. **Create RFC-006** (Event Model & Telemetry) for persistence layer
6. **Create RFC-007** (API Integration Contract) for transport layer

---

**Document Status:** ✅ RFC v1.1 — Production Ready (Post-Review Revision Complete)

**Key Improvements Applied:**
- ✅ Three-stream architecture (domain/analysis/telemetry)
- ✅ Slimmed event payloads (separated analysis from domain events)
- ✅ Added game integrity rules (section 9)
- ✅ Added safety invariants (section 10)
- ✅ Enhanced audit trail (sequenceNumber, eventSource, streamType)
- ✅ Normalized naming conventions (gameMode, rollType)
- ✅ Deprecated RerollEvent in favor of unified RollEvent

**Authors:** Engineering Team  
**Last Updated:** October 25, 2025  
**Version:** 1.1  
**Status:** Ready for Implementation

**Next Steps:**
1. Begin RFC-004 (Game Loop & Mechanics)
2. Implement type generation pipeline
3. Build validation test suite
4. Deploy to RFC-006 (Event Model & Telemetry) persistence layer
